%!TEX root = main-cav.tex

\begin{appendix}

\section{Proofs in Section~\ref{sec-def-snt}}

\noindent {\bf Proposition~\ref{prop-snt-cmm-to-eqv}}. 
\emph{The commutativity problem of SNTs is reduced to the equivalence problem of SNTs in exponential time}.

\begin{proof}
Suppose that $\Ss=(Q, X, Y, \delta, q_0, O)$ is a SNT. Without loss of generality, we assume that the output of $\Ss$ is defined only for data words of length at least two. We will construct two SNTs $\Ss_1$ and $\Ss_2$ so that $\Ss$ is commutative iff $\Ss$ is equivalent to both $\Ss_1$ and $\Ss_2$.
\begin{itemize}
\item The intuition of $\Ss_1$ is that over a data word $w=d_1 d_2 d_3 \dots d_n$ with $n\ge 2$, $\Ss_1$ simulates the run of $\Ss$ over $d_2 d_1 d_3 \dots d_n$, that is, the data word obtained from $w$ by swapping the first two data values.
%
\item The intuition of $\Ss_2$ is that over a data word $w=d_1 d_2 d_3 \dots d_n$ with $n\ge 2$, $\Ss_1$ simulates the run of $\Ss$ over $d_2 d_3 \dots d_n d_1$, that is, the data word obtained from $w$ by moving first data value to the end. 
\end{itemize}
The correctness of this reduction follows from Proposition 1 in \cite{CHSW15}.

\smallskip

\noindent {\it The construction of $\Ss_1$}.

Intuitively, over a data word $w=d_1d_2 d_3 \dots d_n$, we introduce an additional control variable $x'$ to store $d_1$, then simulates the run of $\Ss$ over $d_2 d_1 d_3 \dots d_n$ as follows: When reading $d_2$ in $w$, the data variables are updated properly by letting $x'$ to represent $d_1$ and $\cur$ to represent $d_2$.

Without loss of generality, we assume that for each pair of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2$ in $\Ss$, the following constraints are satisfied,
\begin{itemize}
\item $g_1$ does not contain any variable from $X$,
%
\item for each variable $x \in X$ such that $x$ occurs in $g_2$, it holds that $x \in \dom(\eta_1)$,
%
\item after these two transitions, the values of all the variables from $\dom(\eta_1) \cup \dom(\eta_2)$ are defined, more specifically, for each $y \in Y \cap \dom(\eta_2)$ and each $z \in \vars(\eta_2(y))$, it holds that $z \in \dom(\eta_1)$.
\end{itemize}

Let $q'_{0},q'_{1} \not \in Q$ and $x' \not \in X$. Then $\Ss_1 = (Q \cup \{q'_{0},q'_1\}, X \cup \{x'\}, Y, \delta_1, q'_{0}, O_1)$ such that 
\begin{itemize}
\item $O_1(q'_0)$ and $O_1(q'_1)$ are undefined, and for each $q \in Q$, $O_1(q)=O(q)$,
%
\item $\delta_1$ is constructed from $\delta$ as follows,
\begin{itemize}
\item each element of $\delta$ is an element of $\delta_1$,
%
\item for each pair of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2$ in $\Ss$, we add the transitions $(q_0, \ltrue, \eta'_1, q'_1)$ and $(q'_1, g', \eta'_2, q_2)$ into $\delta_1$, where $\eta'_1,g',\eta'_2$ are defined in the following. Suppose $X \cap \dom(\eta_1)=\{x_1,\dots,x_k\}$, for each $y \in Y \cap \dom(\eta_1)$, $\eta_1(y)=a_{1,y} + b_{1,y}\cur$, and for each $y \in Y \cap \dom(\eta_2)$, 
\[\eta_2(y)=a_{2,y} + b_{2,y} \cur + c_{y,0} y + c_{y,1} x_1 + \dots + c_{y,k} x_k,\] 
or 
\[
\eta_2(y)=a_{2,y} + b_{2,y} \cur + c_{y,1} x_1 + \dots + c_{y,k} x_k.
\]
Then $\eta'_1, g', \eta'_2$ are defined as follows.
\begin{itemize}
\item $\eta'_1(x')=\cur$, for each $x \in X \cap \dom(\eta_2)$, $\eta'_1(x)=\cur$, and for all the other variables $z$ from $X \cup Y$, $\eta'_1(z)$ is undefined.
%
\item $g' = g_1 \wedge g'_2$, where $g'_2$ is obtained from $g_2$ by replacing $\cur$ with $x'$, and each $x \in X$ with $\cur$.
%
\item For each $x \in X$, if $x \in \dom(\eta_2)$, then $\eta'_2(x)$ is undefined, otherwise, if $x \in \dom(\eta_1)$, then $\eta'_2(x)=\cur$, otherwise, $\eta'_2(x)$ is undefined.
%
\item For each $y \in Y$, if $y \in \dom(\eta_2)$, then 
\[
\begin{array}{l c l}
\eta'_2(y) & = & a_{2,y} + b_{2,y} x' + c_{y,0} (a_{1,y} + b_{1,y}\cur) + c_{y,1} \cur + \dots + c_{y,k} \cur \\
& = & (a_{2,y} + c_{y,0} a_{1,y}) + b_{2,y} x' + (c_{y,0} b_{1,y}  + c_{y,1} + \dots + c_{y,k} )\cur,
\end{array}
\]
or 
\[
\begin{array}{l c l}
\eta'_2(y) & = & a_{2,y} + b_{2,y} x' + c_{y,1} \cur + \dots + c_{y,k} \cur \\
& = & a_{2,y} + b_{2,y} x' + (c_{y,1} + \dots + c_{y,k} )\cur.
\end{array}
\]
%
Otherwise, if $y \in \dom(\eta_1)$, then $\eta'_2(y)= a_{1,y} + b_{1,y} \cur$. Otherwise, $\eta'_2(y)$ is undefined.
\end{itemize}
\end{itemize}
\end{itemize}
It is easy to see that the size of $\Ss_1$ is polynomial with respect to the size of $\Ss$.

\smallskip

\noindent {\it The construction of $\Ss_2$}.

Intuitively, over a data word $w=d_1\dots d_n$, we introduce an additional control variable $x'$ to store $d_1$, then simulates the run of $\Ss$ over $d_2\dots d_n d_1$: When reaching the end of $w$, $\Ss_2$ outputs immediately by using $x'$ to represent $d_1$ and simulating the last transition of $\Ss$ over $d_2 \dots d_n d_1$. In order to simulate \emph{deterministically} the last transition of $\Ss$ over $d_2 \dots d_n d_1$ when reading the end of $w$ (since SNTs are required to be deterministic), we need record in the states of $\Ss_2$ the relationship between $d_1$ and all the values stored in the control variables. This implies an exponential blow-up of the size of $\Ss_2$ with respect to $\Ss$.

Let $c_{\max}$ and $c_{\min}$ denote the maximum resp. minimum constant occurring the guards of the transitions of $\Ss$.

Suppose $q'_{0} \not \in Q$ and $x' \not \in X$. Then $\Ss_2 = (Q', Y, \delta_2, q'_{0}, O_2)$, where $O',\delta_2,O_2$ are defined as follows. 
\begin{itemize}
\item $Q' = \{q_0\} \cup \left(\left([c_{\min}, c_{\max}] \cup \{-\infty,+\infty\}\right) \times X^{\{=, <, >,\bot\}} \right)$, where $[c_{\min},c_{\max}]= \{c \in \intnum \mid c_{\min} \le c \le c_{\max} \}$.
%
\item $\delta_2$ is defined as follows, 
\begin{itemize}
\item for each $c \in [c_{\min}, c_{\max}] \cup \{-\infty,+\infty\}$, $\delta_2$ contains $(q'_0,\ltrue,\eta, (q_0,(c, o_0)))$, where $\dom(\eta)=\{x'\}$, $\eta(x')=\cur$, and $o_0(x) = \bot$ for each $x \in X$,
%
\item for each $(q,g,\eta,q') \in \delta$ and $(q,(c,o)) \in Q'$ such that the guard $g \wedge \bigwedge \limits_{x \in X, o(x) \neq \bot} x'\ o(x)\ x$ is satisfiable, then $\delta_2$ contains the following three transitions, 
$((q,(c,o)), g \wedge \cur = x', \eta, (q',(c,o'_1)))$, $((q,(c,o)), g \wedge \cur< x', \eta, (q',(c,o'_2)))$, and $((q,(c,o)), g \wedge \cur > x', \eta, (q',(c,o'_3)))$, 
where 
for each $x \in X$, if $x \in \dom(\eta)$, then $o'_1(x) = \ =$, $o'_2(x)=\ >$, and $o'_3(x) =\ <$, otherwise, $o'_1(x) = o'_2(x) = o'_3(x) = o(x)$.
\end{itemize}
%
\item $O_2$ is defined as follows: For each $(q,(c,o)) \in Q'$  such that there is $(q,g,\eta,q') \in \delta$ satisfying that $\left(\bigwedge \limits_{x \in X, o(x) \neq \bot} \cur\ o(x)\ x \right) \models g$, and $O(q')$ is defined, suppose 
\[O(q')=a+b_1 x_1 + \dots + b_k x_k + c_1 y_1 + \dots + c_l y_l,\]
where $x_1,\dots,x_k$ (resp. $y_1,\dots,y_l$) are pairwise distinct variables from $X$ (resp. $Y$),
then let
\[O_2((q,(c,o)))=a+b_1 \eta'(x_1) + \dots + b_k \eta'(x_k) + c_1 \eta'(y_1) + \dots + c_l \eta'(y_l),\]
where for each $z \in \dom(\eta)$, $\eta'(z)=\eta(z)$, and for all the other variables $z' \in X \cup Y$, $\eta'(z')=z'$.  \\
Note that $O_2$ is well-defined since for each $(q,(c,o)) \in Q'$, there is a unique $(q,g,\eta,q') \in \delta$ satisfying the aforementioned constraint.
\end{itemize}
%
Note that $\Ss_1$ and $\Ss_2$ constructed above preserve the generalized flatness of $\Ss$.
\qed
\end{proof}


\noindent {\bf Proposition \ref{prop-snt-eqv-to-nzero}}.
\emph{From SNT $\Ss_1$ and $\Ss_2$, a SNT $\Ss_3$ can be constructed in polynomial time such that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss_3$ over $w$ is nonzero.}

\begin{proof}
Let $\Ss_1 = (Q_1,X_1,Y_1,\delta_1,q_{1,0}, O_1)$ and  $\Ss_2 = (Q_2,X_2,Y_2,\delta_2,q_{2,0}, O_2)$ be two SNTs. Without loss of generality, we assume that $Q_1 \cap Q_2 = \emptyset$, $X_1 \cap X_2 = \emptyset$, and $Y_1 \cap Y_2 = \emptyset$. 

Intuitively, we construct $\Ss$ as the product of $\Ss_1$ and $\Ss_2$. Specifically, $\Ss=(Q_1 \times Q_2, X_1 \cup X_2, Y_1 \cup Y_2, \delta, (q_{1,0},q_{2,0}), O)$, where
\begin{itemize}
\item $\delta$ comprises $((q_1,q_2), g_1 \wedge g_2, \eta_1 \cup \eta_2, (q'_1,q'_2))$ such that $(q_1,g_1,\eta_1,q'_1) \in \delta_1$ and $(q_2,g_2,\eta_2,q'_2) \in \delta_2$,
%
\item for each $(q_1,q_2) \in Q_1 \times Q_2$, 
\begin{itemize}
\item if $O_1(q_1)$ is defined and $O_2(q_2)$ is undefined or vice versa, then $O((q_1,q_2))=1$, 
%
\item otherwise, if both $O_1(q_1)$ and $O_2(q_2)$ are defined, then $O((q_1,q_2))=O_1(q_1) - O_2(q_2)$, 
%
\item otherwise (both $O_1(q_1)$ and $O_2(q_2)$ are undefined), $O((q_1,q_2))$ is undefined. 
\end{itemize}
\end{itemize}
From the aforementioned construction and the assumption that $\Ss$ is well-defined, it is easy to see that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss$ over $w$ is non-zero.\qed
\end{proof}

\section{Translate a Reducer Program to a SNT}
\begin{algorithm}[H]
	%  \SetAlgoLine
	\KwData{A reducer program $p$}
	$Q=\{q_0\}, \delta=\emptyset, O=\emptyset$, $\mathsf{toState}(p) =q_0$, $\mathsf{toVisit}=\{(\mathsf{toState}(p),p,\ltrue,\emptyset)\}$\;
	\While{$\mathsf{toVisit}\neq \emptyset$}{
		remove $(q,p,g,\eta)$ from $\mathsf{toVisit}$\;
		\Switch{$p$}{
			\lCase{$y := e;p'$,$y \addeq e;p'$,$x'=x;p'$: }{add $(q,p',g,\eta[e/y])$, $(q,p',g,\eta[(y+e)/y])$, $(q,p',g,\eta[x'/x])$ to $\mathsf{toVisit}$, respectively}
			\lCase{$\ite{g'}{s_1}{s_2};p'$: }{add both $(q,s_1;p',g\wedge g',\eta)$ and $(q,s_2;p',g\wedge \neg g',\eta)$ to $\mathsf{toVisit}$}
			\lCase{$\loopL{s;}\mbox{ret }r$: }{add both $(q,s;\loopL{s;}\mbox{ret }r,g,\eta)$ and $(q,\mbox{ret }r, g,\eta)$ to $\mathsf{toVisit}$}
			\lCase{$\next;p'$: }{\label{alg:next}
				\uIf{$\mathsf{toState}(p') \not\in Q$}{add $(\mathsf{toState}(p'),p',\ltrue,\emptyset)$ to $\mathsf{toVisit}$ and add $\mathsf{toState}(p')$ to $Q$}
				add $(q, \mathsf{toState}(p'),g,\eta)$ to $\delta$
			}
			\lCase{$\mbox{ret }r: $}{\label{alg:output}
				add a fresh state $q_r$ to $Q$, 
				add $(q, q_r,g,\eta)$ to $\delta$, and $O:=O[r/q_r]$}
		}
	}
	\Return $(Q,X,Y,\delta, \mathsf{toState}(p),O)$\;
	
	\caption{Translate a Reducer Program to a SNT}
	\label{fig:reducer2SNT}
\end{algorithm}
We use a tuple $(q,p,g,\eta)$ to store intermediate results of the translation, where $q$ is the source SNT state, $p$ is a reducer program, $g$ is a guard, and $\eta$ is an assignment.
The algorithm begins with the tuple $(p,p,\ltrue,\emptyset)$. The algorithm add a transition to SNT only when a $\next$ statement is encountered (line~\ref{alg:next}). When a $\mbox{ret }r$ statement is encountered, the algorithm adds a fresh state $q_r$ to the SNT and extends the output function to $O[r/q_r]$ (line~\ref{alg:output}).





\section{Proofs in Section~\ref{sec-dec-snt}}


\noindent {\bf Proposition~\ref{prop-snt-norm}}.
{\it From each SNT, an equivalent normalized SNT can be constructed in exponential time.} 


\newcommand{\tog}[1]{\mathsf{toGuard(#1)}}
\newcommand{\toec}[1]{\mathsf{toEqClass(#1)}}
\begin{proof}
Given a SNT $\Ss=(Q, X, Y, \delta, q_0, O)$, we show that a normalized ${\Ss}'=(Q', X, Y, \delta', q'_0, O')$ such that ${\Ss}(w) = {\Ss}'(w)$ can be constructed.

We use $X^c$ to denote the set $X^+\cup  \interval{c_{min},c_{max}}$.
%The set of states $Q'=Q\times 2^X \times (X\times X^c) \rightarrow \{=, <, >,  \bot\}$. 
Each state in $Q'$ is a triple $(q, Z, M)$, where $q\in Q$, $Z\in 2^X$ is a set of defined variables, $M: (X\times X^c) \rightarrow \{\hat{=}, \hat{<}, \hat{>}\}$ is a partial function recording the relation between control variables $X$ and elements in $X^+$. Specifically, $M$ is a function from a pair $(x_1, x_2) \in X\times X^c$ to their relationship in $\{\hat{=}, \hat{<}, \hat{>}\}$.  The function $M$ can be translated to a guard with the same meaning as follows $\tog{M}=\bigwedge_{M(x_1,x_2)= \hat{=}} x_1 = x_fv2 \wedge \bigwedge_{M(x_1,x_2)= \hat{>}} x_1 > x_2 \wedge \bigwedge_{M(x_1,x_2)= \hat{<}} x_1 < x_2$. 

We say that $M$ is \emph{consistent} if there is no inconsistency when we saturate it with all indirect relations between elements in $X^c$. E.g., if $M(x_1,x_2)=\hat{>}$, $M(x_2,x_3)=\hat{>}$, and we will have the indirection relation $x_1>x_3$. If we also have $M(x_1,x_2)=\hat{<}$, then we detect an inconsistency. If $M(x_1,x_2)=\bot$ then the saturation procedure set $M(x_1,x_2)=\hat{>}$ because now the relation between is no longer unclear. From a consistent and saturated function $M$, one can induce an equivalence relation between elements in $X^c$, which partition $X^c$ into finite number of classes. We definite the \emph{representative element} of an equivalence class in $M$ as the minimal element w.r.t. the following order $c_{min}<\ldots<c_{max}<x_1<\ldots<x_{|X|}<\cur$. By abusing the notation, we also use $M$ to denote a function maps an element in $x\in X$ to the representative element in $X^c$ of the equivalence class $x$ belongs to.


Let $(q,q',g,\eta)$ be a transition in $\delta$. 
$(q,Z,M) \xrightarrow{(g',\eta')} (q',Z', M') \in \delta$ iff
\begin{itemize}
\item $\tog{M}\wedge g \neq \lfalse$
\item $M'$ is obtained by the following steps: 
  \begin{itemize}
    \item if $\tog{M}\wedge g$ implies $x_1>x_2$, $x_1<x_2$, $x_1=x_2$ for $x_1\in X, x_2\in X^c$, set $M'(x_1,x_2)=\hat{>}$, $M'(x_1,x_2)=\hat{<}$, $M'(x_1,x_2)=\hat{=}$, respectively.
	\item clean all rows and columns related to $\dom(\eta)$, $M':=M'[\bot/(x_1,x_2)]$ for all $x_1\in X\wedge x_2 \in \dom(\eta)$ or $x_1 \in \dom(\eta) \wedge x_2\in X^c$ for $x_1\neq x_2$ 
	\item handle the equivalence related caused by $\eta$, for all $x_1\in X,x_2\in X$ such that $\eta(x_1)=x_2$ execute $M':=M'[\hat{=}/(x_1,x_2)][\hat{=}/(x_2,x_1)]$ and for all $x\in X$ such that $\eta(x)=\cur$ execute $M':=M'[\hat{=}/(x_1,\cur)]$.
	\item saturate $M'$ with all possible indirect relations. 
  \end{itemize}
\item $\eta'(M'(x))= \sub{\eta(x)}{M}$ if $x \in X$ and  $\eta'(y)= \sub{\eta(y)}{M}$ if $y\in Y$.
\item $g'$ is obtained from $g\wedge g^c \wedge \bigwedge_{x \in X} \cur \neq x$ by replacing all occurrences of $x\in\dom(M)$ with $M(x)$, where $g^c\in \{\cur < c_{min}$, $\cur = c$ for $c_{min} \le c \le c_{max}$, $\cur > c_{max}\}\}$. 
\item $Z'= Z\cup (\dom(\eta)\cap X)$.
\end{itemize}
%
The initial state $q_0 = (q_0, \emptyset, M_0)$, where $M_0(x,x) = \hat{=}$ for all $x\in X$.
The output function $O'((q,Z,M))=\bot$ if $\vars(O(q)) \setminus Z\neq \emptyset$, i.e. there are some undefined variables in $O(q)$. Otherwise $O'((q,Z,M))=\sub{O(q)}{M'}$.
\qed
\end{proof}


\noindent {\bf Proposition~\ref{prop-sum-path}}.
{\it The values of the control and data variables after traversing the path $P$ are specified by a function $\chi$ satisfying the following conditions.
\begin{itemize}
\item There is an injective mapping $\pi: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi(j) \le k$, then $\pi(j)=j$ and $\chi(x_j)=d^{(0)}_{j}$, otherwise, $\chi(x_j)=d^{(1)}_{\pi(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi(y_j) = \alpha_{j,0} + \alpha_{j,1} o_j + \beta_{j,1} d^{(0)}_1 + \dots + \beta_{j,k} d^{(0)}_k + \gamma_{j,1} d^{(1)}_1 +\dots + \gamma_{j,r} d^{(1)}_{r}$ for some constants $\alpha_{j,0},\alpha_{j,1}, \beta_{j,1},\dots,\beta_{j,k}, \gamma_{j,1},\dots,\gamma_{j,r}$ such that $\alpha_{j,1} \in \{0,+1,-1\}$ (as a result of the ``independently evolving and copyless'' constraint).
\end{itemize}
}

\begin{proof}
and the $n$ data values met when traversing the path are represented by $d_{k+1},\dots,d_{k+n}$ (these data values may repeat). Then the guards and the assignments in the path induce an equivalence relation $\sim$ on $\{1,\dots, k+n\}$ so that  $i \sim j$ iff it can be inferred from the guards and assignments that $d_i = d_j$. Since $\Ss$ is normalized, we know that for each pair of indices $i,j: 1 \le i < j \le k+n$ such that $i \sim j$, it holds that $j \ge k+1$. Let $I_1,\dots, I_{k+r}$ be an enumeration of the equivalence classes of $\sim$ on $\{1,\dots, k+n\}$ such that $\min(I_1) < \dots < \min(I_{k+r})$. Then for each $j: 1 \le j \le k$, $\min(I_j)=j$.



We show by an induction that for each $i: 1 \le i \le n$ and each variable $x_j \in X$ (resp. $y_j \in Y$), an expression $e_{i,x_j}$ (resp. $e_{i,y_j}$) can be constructed to describe the value of $x_j$(resp. $y_j$) after going through the first $i$ transitions of the path. 
%
\begin{itemize}
\item Let $\theta_0$ be an assignment such that for each $x_j \in X$ (resp. $y_j \in Y$), $\theta_0(x_j)=d^{(0)}_j$ (resp. $\theta_0(y_j)=o_j$), moreover, $\theta_0(\cur)=d^{(1)}_1$.
%
%\item For each $x_j \in X$, if $x_j \in \dom(\eta_1)$, then $e_{1,x_j}=d^{(1)}_1$, otherwise, $e_{1,x_j}=d^{(0)}_j$. For each $y_j \in Y$, if $y_j \in \dom(\eta_1)$, then $e_{1,y_j} = \theta_0(\eta_{1}(y_j))$,
%otherwise, $e_{1,y_j}=o_j$. 
%
\item Let $i: 1 \le i \le n$. 
\begin{itemize}
\item For each $x_j \in X$, if $x_j \in \dom(\eta_i)$, then $e_{i,x_j}=\theta_{i-1}(\cur)$, otherwise, $e_{i,x_j}=\theta_{i-1}(x_j)$.
%
\item For each $y_j \in Y$, if $y_j \in \dom(\eta_i)$, then $e_{i,y_j} = \theta_{i-1}(\eta_i(y_j))$, otherwise, $e_{i,y_j}=\theta_{i-1}(y_j)$.
%
\item For each $x_{j} \in X$ (resp. $y_j \in Y$), $\theta_i(x_{j})=e_{i,x_{j}}$ (resp. $\theta_i(y_{j})=e_{i, y_{j}}$). If $i < n$, then $\theta_i(\cur)=d^{(1)}_{s}$, where $1\le s \le r$ and $k+i + 1 \in I_s$, otherwise, $\theta_i(\cur)=\bot$.
\end{itemize}
\end{itemize}
Then the function $\chi$ can be defined as the restriction of $\theta_n$ to $X \cup Y$.
\qed
\end{proof}


\noindent {\bf Proposition~\ref{prop-sum-cycle}}.
{\it Suppose $P=C^{\ell}$ such that $\ell \ge 2$. Then the function $\chi^{(C)}_{\ell}$ to summarize the computation of $\Ss$ on $P$ is defined as follows,
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0}+ \dots +(\alpha^{(C)}_{j,1})^{\ell-1} \alpha^{(C)}_{j,0}) + (\alpha^{(C)}_{j,1})^\ell o_j + \\
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1}\beta^{(C)}_{j,j'} + \dots +(\alpha^{(C)}_{j,1})^{\ell-1}  \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \\
%
& & \sum \limits_{j'\le k, \pi_C(j') \neq j'} ((\alpha^{(C)}_{j,1})^{\ell-1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( (\alpha^{(C)}_{j,1})^{\ell-2} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +(\alpha^{(C)}_{j,1})^{\ell-1}\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} ((\alpha^{(C)}_{j,1})^{\ell-1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1}\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C},
\end{array} 
\]
where $d^{(C,2)}_{1},\dots, d^{(C,2)}_{r_C},\dots, d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$
 are the data values introduced when traversing $C$ for the second time, $\dots$, and for $\ell$ times.
}
%
\begin{proof}
Let $d^{(C,2)}_{1},\dots,d^{(C,2)}_{r_C}$ be the data values introduced when traversing the cycle for the second time. Then from Corollary~\ref{cor-comp-two-paths}, we know that $\chi^{(C)}_2 = \chi_{C} \circ \chi_C$ is defined as follows: For each $y_j \in Y$,
\[
\begin{array}{l c l}
\smallskip
\chi^{(C)}_2(y_j) & =  & (\alpha^{(C)}_{j,0}+\alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0})+ (\alpha^{(C)}_{j,1})^2 o_j + \\
%
\smallskip
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \sum \limits_{j' \le k, \pi_C(j') \neq j'} (\alpha^{(C)}_{j,1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'}  \\
%
& & + \sum \limits_{j' \le r_C, j' + k \in \rng(\pi_C)} (\beta^{(C)}_{j,\pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} +\\
%
& & \sum \limits_{j' \le r_C, j' + k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + 
 \gamma^{(C)}_{j,1} d^{(C,2)}_1 +\dots + \gamma^{(C)}_{j,r_C} d^{(C,2)}_{r_C}.
\end{array}
\] 
For $\ell > 3$, let $d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$ be the data values introduced when traversing the cycle for the $\ell$-th time. Then from Corollary~\ref{cor-comp-two-paths}, the fact $\chi^{(C)}_\ell = \chi_C \circ \chi^{(C)}_{\ell-1}$, and the induction hypothesis, we can show that $\chi^{(C)}_\ell$ is of the desired form.
\qed
\end{proof}





\subsection{Comparisons with constants in guards}

We now consider the situation that the guards contain the comparisons with constants, that is, the atomic formulae of the form $cur\ o\ c$, where $c$ is an integer constant. 

We illustrate the argument for generalized lassos and adapt the decision procedure Step I-III to Step I$''$-III$''$ below.

Let $q_0 \dots q_m C_1 \dots C_n$ be a generalized lasso and $O(q_m)=a_0 + a_1 x_1 + \dots + a_k x_k + b_1 y_1 + \dots + b_l y_l$.

\smallskip

\noindent {\bf Step I$''$}. Let
\[
\begin{array}{l c l }
\chi_H(O(q_m)) & = & a_0 + a_1 \chi_H(x_1) + \dots + a_k \chi_H(x_k) + b_1 \chi_H(y_1) + \dots b_l \chi_H(y_l) \\
& = & (a_0+b_1 \alpha^{(H)}_{1,0} + \dots + b_l \alpha^{(H)}_{l,0}) + \\
& & \sum \limits_{j \le r_H, j+k \in \rng(\pi_H)} (a_{\pi_H^{-1}(j+k)}+ b_1 \gamma^{(H)}_{j,1}+\dots + b_l \gamma^{(H)}_{j,l}) d^{(0)}_j +
\\
& & \sum \limits_{j \le r_H, j +k \not \in \rng(\pi_H)}  (b_1 \gamma^{(H)}_{j,1}+\dots + b_l \gamma^{(H)}_{j,l}) d^{(0)}_j .
\end{array}
\]
From the guards and assignments of the transitions in $H$, we know that some of $d^{(0)}_1,\dots,d^{(0)}_{r_H}$ are integer constants between $c_{\min}$ and $c_{\max}$. Let $J_H \subseteq \{1,\dots, r_H\}$ denote the indices $j: 1 \le j \le r_H$ such that $d^{(0)}_j = c^{(H)}_j$ for some $c_{\min}\le c^{(H)}_j \le c_{\max}$. Since $\Ss$ is assumed to be normalized, we know that for $j \not \in J_H$,  $d^{(0)}_j < c_{\min}$ or $d^{(0)}_j > c_{\max}$.

For each $j \not \in J_H$, decide whether the coefficient of $d^{(0)}_j$ in $\chi_H(O(q_m))$ is nonzero. If the answer is yes, then return $\ltrue$. 

If the algorithm has not return yet, we substitute the data variables $d^{(0)}_j$ for $j \in J_H$ with the integer constants. Then $\chi_H(O(q_m))$ becomes an integer constant $c_H$. If $c_H \neq 0$, then return $\ltrue$.  Otherwise, go to Step II$''$. \qed

\medskip

For each $i_1: 1 \le i_1 \le n$, let $J_{C_{i_1}}$ denote the indices $j': 1 \le j' \le l$ such that there is $c^{C_{i_1}}_{j'}$ satisfying that $c_{\min} \le c^{C_{i_1}}_{j'} \le c_{\max}$, and for each $i: 1 \le i \le \ell_1$, $d^{(C_{i_1},i)}_{j'}=c^{C_{i_1}}_{j'}$ in $\chi^{(C_{i_1})}_{\ell_1}$. 

For a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$, let $c_{\schm,i_1}$ denote the sum of all the following expressions (intuitively, $c_{\schm,i_1}$ is the constant coefficient of $\chi_\schm(O(q_m))$ involving the terms $ c\ \ell_1$ for some integer constant $c$, when taking into consideration the fact that some introduced data values are in fact integer constants between $c_{\min}$ and $c_{\max}$),
\[
\sum \limits_{1 \le j \le l} 
%\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) 
%\\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \alpha^{(C_{i_1})}_{j,0},
%\end{array}
\]
the expressions 
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) c^{(H)}_{\pi_H(j')-k}
\]
such that $j' \le k$, $\pi_H(j')-k \in J_H$ (Recall that $d^{(0)}_{\pi_H(j')-k}=c^{(H)}_{\pi_H(j')-k}$), \\
the expressions
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left((\alpha^{(C_{i_1})}_{j,1})^{\ell_1-i-1} \beta^{(C_{i_1})}_{j,\pi^{-1}_{C_{i_1}}(j'+k)} + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-i} \gamma^{(C_{i_1})}_{j,j'}\right)
\end{array}
\right) c^{(C_{i_1})}_{j'},
\]
such that $1 \le i < \ell_1$, $j' \in J_{C_{i_1}}$, and $j'+k \in \rng(\pi_{C_{i_1}})$,\\
the expressions
\[
\left(\sum \limits_{1 \le j \le l} 
%\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right)  \left( (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-i} \gamma^{(C_{i_1})}_{j,j'}\right)
%\end{array}
\right) c^{(C_{i_1})}_{j'},
\]
such that $i: 1 \le i \le \ell_1$, $j' \in J_{C_{i_1}}$, and $j'+k \not \in \rng(\pi_{C_{i_1}})$.

Then $c_{\schm,i_1}$ can be rewritten as $\mu_{\schm, (i_1,0)} \ell_1 + \nu_{\schm, (i_1,0)}$ for constants $\mu_{\schm, (i_1,0)},\nu_{\schm, (i_1,0)}$.

\medskip

\noindent {\bf Step II$''$}. For each $i_1: 1 \le i_1 \le n$, if there are a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$  and $j' \le k$ such that 
\begin{itemize}
\item $i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
\item $\pi_H(j')-k \not \in J_H$, $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$, 
\end{itemize}
then return $\ltrue$.

If there is a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that 
$i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
and $\mu_{\schm,(i_1,0)} \neq 0$, 
%
then return $\ltrue$. 

If the decision procedure has not return yet, then go to Step III$''$. \qed

\medskip

If after Step II, the algorithm has not return yet, then after removing the terms involving $c\ \ell_1,\dots, c\ \ell_t$, a finite state automaton $\Aa$ can be constructed to simulate the evolvement of the coefficients of the non-constant data variables, and the sum of the constant coefficients and all the terms involving the data variables which are integer constants. 

\medskip



\noindent {\bf Step III$''$}. For each final state $\chi$ of $\Aa$, do the following.
\begin{itemize}
\item Check whether the coefficient of some non-constant data variable in $\chi(O(q_m))$ is nonzero, if the answer is yes, then return $\ltrue$.
%
\item Otherwise, check whether the number obtained from $\chi(O(q_m))$ by replacing the remaining data variables with the corresponding integer constants, is nonzero. If the answer is yes, then return $\ltrue$. 
\end{itemize}
Finally, return $\lfalse$ and the algorithm terminates.

\end{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



