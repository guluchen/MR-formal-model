\documentclass[runningheads,a4paper]{llncs}

\usepackage{latexsym}
\usepackage{setspace}
\usepackage{cancel}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{appendix}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{leftidx}
\usepackage{mathtools}
\usepackage[linesnumbered,noend]{algorithm2e}
\usepackage{paralist}


%\usepackage{cancel}
%\usepackage{verbatim}
%\usepackage{chngpage}
%\usepackage{fullpage}

\usepackage{color}
\usepackage{wrapfig}
\usepackage{mathrsfs}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{times}
%\usepackage{pslatex}
\newcommand{\hide}[1]{}

\newcommand*\circled[1]{\overline{#1}}

%\newtheorem{definition}{Definition}
%\newtheorem{theorem}{Theorem}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{example}{Example}
%\newtheorem{question}{Open Question}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{Algo}{Algorithm}
%\newtheorem{remark}[theorem]{Remark}

\def\arr#1{\stackrel{#1}{\longrightarrow}}

\def\Aa{{\mathcal{A} }}

\def\Bb{{\mathscr{B} }}

\def\Cc{{\mathcal{C} }}

\def\Dd{{\mathbb{D} }}

\def\Ee{{\mathcal{E} }}

\def\Ff{{\mathcal{F} }}

\def\Zz{{\mathcal{Z} }}

\def\Nn{{\mathbb{N} }}

\def\Ss{{\mathcal{S} }}

\def\schm{{\mathfrak{s} }}

\def\Tt{{\mathcal{T} }}

\def\Ii{{\mathbb{Z} }}

\def\Jj{{\mathcal{J}}}

\def\Vv{{\mathcal{V}}}

\def\Rr{{\mathcal{R} }}

\def\Ll{{\mathcal{L}}}

\def\Kk{{\mathcal{K}}}


\def\treeset{{\mathscr{T}}}

\def\contextset{{\mathcal{C}}}

\def\theory{{\mathcal{L}}}

\def\termset{{\mathcal{T}}}

\def\formulaset{{\mathcal{F}}}

\newcommand\univ{\mathsf{Univ}}

\newcommand\op{\mathfrak{o}}

\newcommand\dv{\mathtt{x}}

\newcommand\ydv{\mathtt{y}}

\newcommand\cv{\mathtt{z}}

\newcommand\thla{\mathcal{LIA}}

\newcommand\thdif{\mathcal{DIF}}

\newcommand\thord{\mathcal{ORD}}

\newcommand\thset{\mathcal{SET}}

\newcommand\thmset{\mathcal{MUS}}

\newcommand\natnum{{\mathbb{N} }}

\newcommand\intnum{{\mathbb{Z} }}

\newcommand\intnumnz{\mathbb{Z}^{\neq 0}}

\newcommand\cur{\mathsf{cur}}
\newcommand\nnext{\mathsf{next}}
\newcommand\head{\mathsf{hd}}
\newcommand\tail{\mathsf{tl}}
\newcommand\init{\mathsf{init}}

\newcommand{\loopL}[1]{\mbox{loop\{} #1\mbox{\}}}
\newcommand{\ite}[3]{\mbox{if } (#1) \{#2\} \mbox{ [else } \{#3\}\mbox{]} }

\newcommand\vars{\mathsf{vars}}

\newcommand\intvars{\mathcal{X}}

\newcommand\dom{\mathsf{dom}}

\newcommand\rng{\mathsf{rng}}

\newcommand\ltrue{\mathsf{true}}

\newcommand\lfalse{\mathsf{false}}

\newcommand\avg{\mathrm{avg}}

\newcommand\maxv{\mathsf{max}}

\newcommand\sumv{\mathsf{sum}}

\newcommand\cntv{\mathsf{cnt}}

\newcommand\addeq{+\!\!=}

\newcommand\defval{\mathsf{DEF}}

%\newcommand{\sub}[2]{\mathsf{sub}_{#2}(#1)}
\newcommand{\eval}[2]{\llbracket#1\rrbracket_{#2}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%The macros introduced by Zhilin%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\sval}{\Omega}
\newcommand{\sumf}{\Theta}
\newcommand{\initval}{\sval}

% The macros for the data variables.
\newcommand{\vard}{\mathfrak{d}}
\newcommand{\vare}{\mathfrak{e}}
\newcommand{\varf}{\mathfrak{f}}
\newcommand{\varo}{\mathfrak{o}}
\newcommand{\varx}{\mathfrak{x}}
\newcommand{\vary}{\mathfrak{y}}

% The macros for the data variables.
\newcommand{\csta}{\alpha}
\newcommand{\cstb}{\beta}
\newcommand{\cstg}{\gamma}
\newcommand{\cste}{\varepsilon}
\newcommand{\cstl}{\lambda}
\newcommand{\cstm}{\mu}
\newcommand{\cstn}{\nu}


\newcommand{\gmlasso}{\mathfrak{m}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\abs}{\mathsf{Abs}}

\newcommand{\cabs}{\mathscr{F}}

\newcommand{\sntcset}{\mathscr{C}}

\newcommand{\sntc}{\mathsf{cl}}

\newcommand{\interval}[1]{[#1]}
%\def\Ss{{$\mathcal{A}$\ }}

\title{The~Commutativity~Problem~of~the~MapReduce Framework: A Transducer-based Approach}
\titlerunning{Commutativity of MapReduce: A Transducer-based Approach}

\institute{Institute of Information Science, Academia Sinica \and State Key Laboratory of Computer Science,\\ Institute of Software, Chinese Academy of Sciences }


%\institute{Institute of Information Science, Academia Sinica \and State Key Laboratory of Computer Science,\\ Institute of Software, Chinese Academy of Sciences }


\author{Yu-Fang Chen\inst{1}, Lei Song\inst{2}, Zhilin Wu\inst{2}}

\begin{document}

\maketitle

\begin{abstract}

MapReduce is a popular programming model for data parallel computation. 
In MapReduce, the \emph{reducer} produces an output from a list of inputs. Due to the scheduling policy of the platform, the inputs may arrive at the reducers in different order. The \emph{commutativity problem} of reducers asks if the output of a reducer is independent of the order of its inputs. Although the problem is undecidable in general,
the MapReduce programs in practice are usually used for data analytics and thus require very simple control flow. 
By exploiting the simplicity, we propose a programming language for reducers where the commutativity problem is decidable. The main idea of the reducer language is to separate the control and data flow of programs and disallow arithmetic operations in the control flow.
The decision procedure for the commutativity problem of reducer programs is obtained through a reduction to the equivalence problem of \emph{streaming numerical transducers} (SNTs), a novel automata model over infinite alphabets introduced in this paper. The design of SNTs is inspired by streaming transducers (Alur and Cerny, POPL 2011). Nevertheless, the two models are intrinsically different since the outputs of SNTs are integers while those of streaming transducers are data words. 
The decidability of the equivalence of SNTs is achieved with an involved combinatorial analysis of the evolvement of the values of the integer variables during the runs of SNTs.

\end{abstract}

\vspace{-0.8cm}
\input{1_intro.tex}

\vspace{-0.3cm}
\input{2_prel.tex}

\vspace{-0.3cm}
\input{3_program.tex}

\vspace{-0.3cm}
\input{4_snt.tex}

\vspace{-0.3cm}
\input{5_dec-proc.tex}

\input{6_case-stud.tex}
\vspace{-0.3cm}

\vspace{-0.2cm}
\input{7_conc.tex}
\vspace{-0.5cm}


\bibliographystyle{abbrv}
\bibliography{data}

%\newpage

%\input{8_append.tex}

%Program =>SNT exp in number of branches in loop
% Program communtativity to SNT non-zeroness => also exp in number of branches in loop and number of variables
%The SNT equivalence to nonzeroness=> Poly
%SNT nonzeroness
%StepI poly in the length of handle
%StepII exp in the number of cycles
%StepIII exp in the number of data variables

\end{document}