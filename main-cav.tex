\documentclass[runningheads,a4paper]{llncs}

\usepackage{latexsym}
\usepackage{setspace}
\usepackage{cancel}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{appendix}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{leftidx}
\usepackage{mathtools}
\usepackage[linesnumbered,noend]{algorithm2e}
\usepackage{paralist}


%\usepackage{cancel}
%\usepackage{verbatim}
%\usepackage{chngpage}
%\usepackage{fullpage}

\usepackage{color}

\usepackage{mathrsfs}
\usepackage{tikz}
\usetikzlibrary{shapes}
\usepackage{times}
%\usepackage{pslatex}
\newcommand{\hide}[1]{}

\newcommand*\circled[1]{\overline{#1}}

%\newtheorem{definition}{Definition}
%\newtheorem{theorem}{Theorem}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{example}{Example}
%\newtheorem{question}{Open Question}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{Algo}{Algorithm}
%\newtheorem{remark}[theorem]{Remark}

\def\arr#1{\stackrel{#1}{\longrightarrow}}

\def\Aa{{\mathcal{A} }}

\def\Bb{{\mathscr{B} }}

\def\Cc{{\mathcal{C} }}

\def\Dd{{\mathbb{D} }}

\def\Ee{{\mathcal{E} }}

\def\Ff{{\mathcal{F} }}

\def\Zz{{\mathcal{Z} }}

\def\Nn{{\mathbb{N} }}

\def\Ss{{\mathcal{S} }}

\def\schm{{\mathfrak{s} }}

\def\Tt{{\mathcal{T} }}

\def\Ii{{\mathbb{Z} }}

\def\Jj{{\mathcal{J}}}

\def\Vv{{\mathcal{V}}}

\def\Rr{{\mathcal{R} }}

\def\Ll{{\mathcal{L}}}

\def\Kk{{\mathcal{K}}}


\def\treeset{{\mathscr{T}}}

\def\contextset{{\mathcal{C}}}

\def\theory{{\mathcal{L}}}

\def\termset{{\mathcal{T}}}

\def\formulaset{{\mathcal{F}}}

\newcommand\univ{\mathsf{Univ}}

\newcommand\op{\mathfrak{o}}

\newcommand\dv{\mathtt{x}}

\newcommand\ydv{\mathtt{y}}

\newcommand\cv{\mathtt{z}}

\newcommand\thla{\mathcal{LIA}}

\newcommand\thdif{\mathcal{DIF}}

\newcommand\thord{\mathcal{ORD}}

\newcommand\thset{\mathcal{SET}}

\newcommand\thmset{\mathcal{MUS}}

\newcommand\natnum{{\mathbb{N} }}

\newcommand\intnum{{\mathbb{Z} }}

\newcommand\cur{\mathsf{cur}}
\newcommand\nnext{\mathsf{next}}
\newcommand\head{\mathsf{hd}}
\newcommand\tail{\mathsf{tl}}
\newcommand\init{\mathsf{init}}

\newcommand{\loopL}[1]{\mbox{loop\{} #1\mbox{\}}}
\newcommand{\ite}[3]{\mbox{if } #1 \mbox{ then } #2\mbox{ else }#3 }



\newcommand\vars{\mathsf{vars}}

\newcommand\intvars{\mathcal{X}}

\newcommand\dom{\mathsf{dom}}

\newcommand\rng{\mathsf{rng}}

\newcommand\ltrue{\mathsf{true}}

\newcommand\lfalse{\mathsf{false}}

\newcommand\avg{\mathrm{avg}}

\newcommand\maxv{\mathsf{max}}

\newcommand\sumv{\mathsf{sum}}

\newcommand\cntv{\mathsf{cnt}}

\newcommand\addeq{+\!\!=}

\newcommand\defval{\mathsf{DEF}}

%\newcommand{\sub}[2]{\mathsf{sub}_{#2}(#1)}
\newcommand{\eval}[2]{\llbracket#1\rrbracket_{#2}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%The macros introduced by Zhilin%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\sval}{\Omega}
\newcommand{\sumf}{\Theta}
\newcommand{\initval}{\sval}

% The macros for the data variables.
\newcommand{\vard}{\mathfrak{d}}
\newcommand{\vare}{\mathfrak{e}}
\newcommand{\varf}{\mathfrak{f}}
\newcommand{\varo}{\mathfrak{o}}
\newcommand{\varx}{\mathfrak{x}}
\newcommand{\vary}{\mathfrak{y}}

% The macros for the data variables.
\newcommand{\csta}{\alpha}
\newcommand{\cstb}{\beta}
\newcommand{\cstg}{\gamma}
\newcommand{\cste}{\varepsilon}
\newcommand{\cstl}{\lambda}
\newcommand{\cstm}{\mu}
\newcommand{\cstn}{\nu}


\newcommand{\gmlasso}{\mathfrak{m}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\abs}{\mathsf{Abs}}

\newcommand{\cabs}{\mathscr{F}}

\newcommand{\sntcset}{\mathscr{C}}

\newcommand{\sntc}{\mathsf{cl}}



\newcommand{\yfc}[1]{\color{blue} {YF: #1 :FY} \color{black}}
\newcommand{\zhilin}[1]{\color{cyan} {ZL: #1 :LZ} \color{black}}
\newcommand{\lei}[1]{\color{green} {LE: #1 :EL} \color{black}}
\newcommand{\SDSIT}{SDSIT}
\newcommand{\Name}{Streaming data string to integer transducer}
\newcommand{\name}{streaming data string to integer transducer}
\newcommand{\interval}[1]{[#1]}
%\def\Ss{{$\mathcal{A}$\ }}

\title{The~Commutativity~Problem~of~the~MapReduce Framework: A Transducer-based Approach}
\titlerunning{Commutativity of MapReduce: A Transducer-based Approach}
\author{}
\institute{}

%\author{Yu-Fang Chen, Lei Song, Zhilin Wu}

\begin{document}

\maketitle

\begin{abstract}

MapReduce is a popular programming model for data parallel computations. 
In MapReduce, the \emph{reducer} produces an output from a list of inputs. Due to the scheduling policy of the platform, the inputs may arrive at the reducers in different order. The \emph{commutativity problem} of reducers asks if the output of a reducer is independent of the order of its inputs. Although the problem is undecidable in general,
%due to Rice's theorem and thus is seemingly uninteresting. 
the MapReduce programs in practice are usually used for data analytics and thus require very simple data and control flow. 
By exploiting the simplicity, we propose a programming language for reducers where the commutativity problem is decidable.
 %The programming language is capable of modeling many daily tasks in practice, e.g. the aggregate functions $sum$, $max$, $min$, $count$, the filters like $age \ge 18$, as well as their compositions. 
The decision procedure is obtained through a reduction to the equivalence problem of \emph{streaming numerical transducers} (SNTs), a novel automata model over infinite alphabets introduced in this paper. The design of SNTs is inspired by streaming transducers (Alur and Cerny, POPL 2011). Nevertheless, the two models are intrinsically different since the outputs of SNTs are integers while those of streaming transducers are data strings. 
%The main ingredients of SNTs are to divide the set of variables into the set of control variables and data variables where the control variables can be used in the guards of transitions, but without arithmetics, on the other hand, the data variables are allowed to be updated with arithmetics, but they are forbidden to occur in the guards. 
The decidability of the equivalence of SNTs is achieved with an involved combinatorial analysis of the evolvement of the values of the integer variables during the runs of SNTs.
%We show that the language is expressive enough for common data analytics operations.
\end{abstract}

\input{1_intro.tex}

\input{2_prel.tex}

\input{3_program.tex}

\input{4_snt.tex}

\input{5_dec-proc.tex}

\input{6_case-stud.tex}

\input{7_conc.tex}


\bibliographystyle{abbrv}
\bibliography{data}

\newpage

\input{8_append.tex}

\end{document}