\documentclass[runningheads,a4paper]{llncs}

\usepackage{latexsym}
\usepackage{setspace}
\usepackage{cancel}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{appendix}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{leftidx}
\usepackage{mathtools}
\usepackage[linesnumbered,noend]{algorithm2e}

%\usepackage{cancel}
%\usepackage{verbatim}
%\usepackage{chngpage}
%\usepackage{fullpage}

\usepackage{color}

\usepackage{mathrsfs}

%\newtheorem{definition}{Definition}
%\newtheorem{theorem}{Theorem}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{example}{Example}
%\newtheorem{question}{Open Question}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{Algo}{Algorithm}
%\newtheorem{remark}[theorem]{Remark}

\def\arr#1{\stackrel{#1}{\longrightarrow}}

\def\Aa{{\mathcal{A} }}

\def\Bb{{\mathscr{B} }}

\def\Cc{{\mathcal{C} }}

\def\Dd{{\mathbb{D} }}

\def\Ee{{\mathcal{E} }}

\def\Ff{{\mathcal{F} }}

\def\Zz{{\mathcal{Z} }}

\def\Nn{{\mathbb{N} }}

\def\Ss{{\mathcal{S} }}

\def\schm{{\mathfrak{s} }}

\def\Tt{{\mathcal{T} }}

\def\Ii{{\mathbb{Z} }}

\def\Jj{{\mathcal{J}}}

\def\Vv{{\mathcal{V}}}

\def\Rr{{\mathcal{R} }}

\def\Ll{{\mathcal{L}}}


\def\treeset{{\mathscr{T}}}

\def\contextset{{\mathcal{C}}}

\def\theory{{\mathcal{L}}}

\def\termset{{\mathcal{T}}}

\def\formulaset{{\mathcal{F}}}

\newcommand\univ{\mathsf{Univ}}

\newcommand\op{\mathfrak{o}}

\newcommand\dv{\mathtt{x}}

\newcommand\ydv{\mathtt{y}}

\newcommand\cv{\mathtt{z}}

\newcommand\thla{\mathcal{LIA}}

\newcommand\thdif{\mathcal{DIF}}

\newcommand\thord{\mathcal{ORD}}

\newcommand\thset{\mathcal{SET}}

\newcommand\thmset{\mathcal{MUS}}

\newcommand\natnum{{\mathbb{N} }}

\newcommand\intnum{{\mathbb{Z} }}

\newcommand\cur{\mathsf{cur}}
\newcommand\next{\mathsf{next}}
\newcommand\head{\mathsf{hd}}
\newcommand\tail{\mathsf{tl}}

\newcommand{\loopL}[1]{\mbox{loop\{} #1\mbox{\}}}
\newcommand{\ite}[3]{\mbox{if } #1 \mbox{ then } #2\mbox{ else }#3 }



\newcommand\vars{\mathsf{vars}}

\newcommand\intvars{\mathcal{X}}

\newcommand\dom{\mathsf{dom}}

\newcommand\rng{\mathsf{rng}}

\newcommand\ltrue{\mathsf{true}}

\newcommand\lfalse{\mathsf{false}}

\newcommand\avg{\mathrm{avg}}

\newcommand\maxv{\mathsf{max}}

\newcommand\sumv{\mathsf{sum}}

\newcommand\cntv{\mathsf{cnt}}

\newcommand\addeq{+\!\!=}

\newcommand\defval{\mathsf{DEF}}

\newcommand{\sub}[2]{\mathsf{sub}_{#2}(#1)}
\newcommand{\eval}[2]{\llbracket#1\rrbracket_{#2}}

% The macros for the data variables.
\newcommand{\vard}{\mathfrak{d}}
\newcommand{\vare}{\mathfrak{e}}
\newcommand{\varf}{\mathfrak{f}}
\newcommand{\varo}{\mathfrak{o}}
\newcommand{\varx}{\mathfrak{x}}
\newcommand{\vary}{\mathfrak{y}}

% The macros for the data variables.
\newcommand{\csta}{\alpha}
\newcommand{\cstb}{\beta}
\newcommand{\cstc}{\gamma}
\newcommand{\cste}{\varepsilon}
\newcommand{\cstl}{\lambda}
\newcommand{\cstm}{\mu}
\newcommand{\cstn}{\nu}

\newcommand{\hide}[1]{}
\newcommand{\yfc}[1]{\color{blue} {YF: #1 :FY} \color{black}}
\newcommand{\zhilin}[1]{\color{cyan} {ZL: #1 :LZ} \color{black}}
\newcommand{\lei}[1]{\color{green} {LE: #1 :EL} \color{black}}
\newcommand{\SDSIT}{SDSIT}
\newcommand{\Name}{Streaming data string to integer transducer}
\newcommand{\name}{streaming data string to integer transducer}
\newcommand{\interval}[1]{[#1]}
%\def\Ss{{$\mathcal{A}$\ }}

\title{The~Commutativity~Problem~of~the~Map-Reduce Framework: A Transducer-based Approach}
\titlerunning{Commutativity of MapReduce: A Transducer-based Approach}
\author{}
\institute{}

%\author{Yu-Fang Chen, Lei Song, Zhilin Wu}

\begin{document}

\maketitle

\begin{abstract}

MapReduce is a popular programming model for data parallel computation. 
In MapReduce, the \emph{reducer} produces an output from a list of inputs. Due the scheduling policy and the settings of machines, the input may arrive the reducers with different orders. The \emph{commutative problem} of reducers asks if the output of a reducer independent of the order of its inputs. The problem is in general undecidable due to Rice's theorem and thus is seemingly uninteresting. However, the MapReduce model is usually used for data analytics and thus requires very simple data and control flow. 
By exploiting the simplicity, we propose a simple programming language for reducers where the commutative problem can be decide by a reduction to the equivalence problem of \emph{streaming numerical transducers} (SNTs). 
%We show that the language is expressive enough for common data analytics operations.
\end{abstract}

\section{Introduction}
%What is Map-Reduce
MapReduce is a  popular framework for data parallel computation. It has been adopt in various cloud computing frameworks such as Hadoop~\cite{Hadoop} and Spark~\cite{Spark}. In a typical Map-Reduce program, a \emph{mapper} reads from data sources and outputs a list of key-value pairs. 
The load balance mechanism of the Map-Reduce framework reorganizes the key-value pairs $(k, v_1), (k,v_2)\ldots(k,v_n)$ with the same key $k$ to a pair $(k,l)$, where $l$ is a list of values $v_1,v_2,\ldots,v_n$, and sends $(k,l)$ to a \emph{reducer}. The reducer then iterates through the list and output a key-value pair.

To be more concrete, taking the ``word-counting'' MapReduce program as an example. It counts the occurrences of each word in a set of documents. The mappers reads the documents and output for each document a list in the form of $(word_1, count_1), (word_2, count_2), \ldots, (word_n, count_n)$, where $count_k$ is the number of occurrences of $word_k$ in the document being processed. These lists will be reorganized into the form of $(word_1, list_1), (word_2,list_2), \ldots, (word_n,list_n)$ and sent to the reducers, where $list_k$ is a list of integers recording the number of occurrences of $word_k$ in the set of documents. Note that the \emph{order} of the integers in the lists can differ in different executions due to network latency, load balancing, etc.
This results in the \emph{commutativity problem}.

%The communitativity problem
We say that a reducer is \emph{commutativity} if its output is independent of the order of its inputs. The commutativity problem asks if a reducer is commutativity. A study from Microsoft~\cite{XZZ+14} reports that 58\% of the 507 reducers submit to their MapReduce platform are non-commutative. 
Those reducers already went through serious code review, testing, and experiments with real data for more than three months. Still, among them 5 reducers containing very subtle bugs caused by non-commutativity (confirmed by the programmers). 
So we know that non-commutativity is a good indicator for potential program errors. 
Moreover, having the commutativity property makes reproducing a bug found by program testing easier.

%The reason for studying syntatical restrictions 
The reducer commutative problem in general is undecidable by Rice's theorem. However, in practice, the reducers are seldom Turing machines. They are usually used for data analytics and have very simple control structures. Many of them just iterate through the input list and compute the output with very simple operations.
We want to study if the commutative problem of real-world reducers are decidable.

A simple programming language of reducers over integers has been considered in~\cite{CHSW15}, where the only loop structure allowed is an iteration over the input list and it is not allowed to reset the iterator to the list head. They show that the commutative problem of programs written by such a simple language is undecidable by a reduction from the satisfiability problem of Diophantine equations. Under scrutiny, we found that the language is still too expressive for typical data analytics programs. For example, it allows multiplications of two different variables, which is a key element in the undecidability proof. 

By observing the behavioral pattern of reducer programs for data analytics, we characterize the essential components in a programming language for reducers. %However, we found that even only with the essential parts of the language, the commutativity problem is still undecidable. 
Inspired by~\cite{RP11}, we found that the commutativity problem becomes decidable if we partition variables into \emph{control variables} and \emph{data variables}. Data variables cannot be used in transition guards and control variables can store only elements in the input list (e.g., it is not allowed to store the sum of two variables in a control variable). 
We believe such concepts provide good insights for reducer programming language design.

We define a formalism named \emph{streaming numerical transducers (SNT)} and use it to create a decision procedure for the reducer commutative problem.
SNTs combine the features of register automata~\cite{XX} and vector addition system with states (VASS)~\cite{YY} with restrictions on the structure of the transition systems.
We show that the equivalence, commutative, and non-zeroness problems of SNTs are decidable.
Moreover, SNTs can be composed to form a commutative/equivalence proof of reducer programs that read the input list multiple times.
On theoretical point of view, the study of deterministic SNT is
interesting on its own right. It is tightly related to both register automata and integer VASS and the decidability of its decision problems is seemingly non-trivial. 

The rest of the paper is organized as follows. Section~\ref{sec:preliminaries} describes design of the streaming numerical transducer model, including the formal definition, the rationale behind the model design, and the types of data analytics reducer programs it can express. Section~\ref{sec:decision} discusses the decision problems and the procedure for solving the problems.

\section{Preliminaries}
%
Let $\intnum$,  $\intnum^+$ be the set of integers, positive integers, respectively, and $\bot \not \in \intnum$ be 
the undefined value. By convention, it is assumed that $\bot + \bot = \bot$, $\bot + n = \bot$ for each $n \in \intnum$, $0 \times \bot = 0$, and $n \times \bot = \bot$ for each $n \in \intnum^+$.
In this paper, we assume that all variables range over $\intnum \cup \{\bot\}$.  

For a function $\pi$, let $\dom(\pi)$ and $\rng(\pi)$ denote the \emph{domain}  and \emph{range} of $\pi$, respectively. 
An \emph{expression} $e$ over the set of variables $Z$ is defined by the following rules, $e\equiv  c \mid  c z \mid (e + e) \mid (e - e)$, where $z \in Z$ and $c\in \intnum$.  As a result of the commutativity of $+$, without loss of generality, we assume that all expressions $e$ in this paper are of the form $c_1 z_1 + \dots c_n z_n$, where $c_1,\dots,c_n \in \intnum$ and $z_1,\dots,z_n \in Z$. \zhilin{I changed a bit the definition of expressions here}

For an expression $e$, let $\vars(e)$ denote the set of variables occurring in $e$. Let $\Ee_Z$ denote the set of all expressions over the set of variables $Z$. Let $e$ be an expression and $\eta$ be a partial function from $\vars(e)$ to expressions. Then we use $\sub{e}{\eta}$ to denote the expression obtained from $e$ by replacing each variable $z \in \vars(e)\cap\dom(\eta)$ with $\eta(z)$. A \emph{valuation} $\rho$ of variables $Z$ is a function from $Z$ to $\intnum \cup \{\bot\}$. The value of $e$ under $\rho$, denoted by $\eval{e}{\rho}$, is defined as the value obtained by replacing each variable $z \in \vars(e)$ in $e$ with $\rho(z)$.
For a valuation $\rho$, we define its extension $\rho[d/x]$ such that $\rho[d/x](x)=d$ and $\rho[d/x](y)=\rho(y)$ for $y\neq x$.

In this paper, we use $X$ and $Y$ to denote the sets of \emph{control variables} and \emph{data variables}, respectively. We use the variable $\cur \notin X\cup Y$ to store the data value that is currently being processed in the input list and use $X^+$ to denote the set $X\cup \{\cur\}$.
A \emph{guard} is a formula defined by the following rules, $g::= \ltrue \mid \cur\odot c \mid \cur\odot x \mid g \wedge g$, where $\odot \in \{=,\neq,<, >, \le, \ge\}$, $x \in X^+$, and $c\in \intnum$. 
Let $\rho$ be a valuation and $g$ be a guard. Then $\rho$ satisfies $g$, denoted by $\rho \models g$, iff for each variable $z \in \vars(g)$, $\rho(z) \neq \bot$, and $g$ is evaluated to $\ltrue$ under $\rho$. An \emph{assignment} $\eta$ for $X \cup Y$ is a partial function from $X \cup Y$ to $\Ee_{X^+ \cup Y}$ such that for each $x \in \dom(\eta) \cap X$, $\eta(x)=\cur$ or $\eta(x) = x'$ for some $x' \in X$.

Let $\interval{n}$ be the set $\{ 1, 2, \ldots, n \}$. A \emph{permutation} on
$\interval{n}$ is a one-to-one and onto mapping from $\interval{n}$ to
$\interval{n}$. The set of
permutations on $\interval{n}$ is denoted by $S_n$.

Define the two functions $\pi_2$ and $\pi_n$ as follows : $\pi_2(1)=2,\pi_2(2)=1,\pi_2(k)=k$, for $k>2$ and
$\pi_n(1)=2,\pi_n(2)=3,\ldots,\pi_n(n)=1, \pi_n(k)=k$, for $k>n$.

\begin{theorem}[\cite{algebra}]
	For every permutation $\sigma \in S_n$, $\sigma$ is equal to a
	composition of $\tau_2$ and $\tau_n$.
	\label{theorem:symmetric-basis}
\end{theorem}

A \emph{list $w$} is a sequence of integer values $d_1\ldots d_n$ such that $d_i \in \intnum$ for each $i$.
We use $\head(w)$, $\tail(w)$, and $|w|$ to denote the \emph{head}, \emph{tail}, and \emph{length} of $w$, respectively.
We use $\emptyset$ to denote an empty list.
Given two lists $w,w'$, we use $w.w'$ to denote their concatenation.
Under the context of a transducer, we use the alternative name \emph{data word} to refer to a list.
Given a list $l=d_1\ldots d_n$ and a permutation $\sigma \in S_n$, we lift the permutation function to list by defining $\sigma(l)=d_{\pi(1)} \ldots d_{\pi(n)}$.

 
\section{Language For Integer Reducers}\label{sec-mr-prog}
We discuss the rationale behind the design of the programming language for reducers such that the commutativity problem is decidable.
We focus on a language that only allow to iterate though the input list once. Later we will show an extension that allows the reset of list iterators.



\begin{figure}
	\centering
	\begin{tabular}{rcl}
        $ s \in Statements$&$\equiv$&$y := e\mid y \addeq e \mid x:=x'\mid s;s\mid \next \mid \ite{g}{s}{s}$\\
		$ p\in Programs$&$\equiv$&$\loopL{s};\mbox{ret }r \mid s;p$		
	\end{tabular}
	\label{fig:language}
	\caption{A Simple Programming Language for Reducers. Here $x\in X$ are control variables, $y\in Y$ are data variables, $x' \in X^+$, $e\in \Ee_{X^+}$ are expressions, $r$ is a $k$-tuple in $\Ee_{X^+ \cup Y}^k$, and $c\in \mathbb{Z}$.}
\end{figure}

To be more concrete, we focus on the programming language in Figure~\ref{fig:language}.
The main feature of the language is that we partition the variables into two sets: \emph{control variables} and \emph{data variables}.
The former are used for guiding the program flow and the latter used for storing aggregated results.
To be more specific, the control variables can store only values occurred in the input and can be used either in guard or arithmetic expressions.
The data variables can store the results obtained from an arithmetic expression, but cannot be used either in guards or arithmetic expressions.

Note that we do not allow multiplication in the language, so the reduction from the satisfiability of Diophantine equations no longer works. Even though, if we do not distinguish the control and data variables, we can show easily that basic decision problems for this language are still undecidable, by a reduction from the reachability problem of Perti-net with zero test~\cite{petri}.
Intuitively, variables are used for remembering the number of tokens in each place. Transitions between places can be described as assignments to variables in the loop body: each loop iteration makes a Petri-net transition. 
The non-determinism in transitions is expressed by branching over the input. 
The guards in transitions are expressed by branching over the variables (recall that we are discussing the version that we do not distinguishing data and control variables). Then the reachability problem of Perti-net with zero test can be reduced to reachability problem in the programming language.


\begin{figure}
	\centering
	\lstset{language=C,
		basicstyle=\ttfamily\scriptsize}
	\begin{tabular}{|c|c|c|}
		\hline
		\begin{minipage}[t]{0.39\textwidth}
			(a)
			\begin{lstlisting}[mathescape=true]
max_abs {
 if $\cur$>0 then max:=$\cur$
 else max:= -$\cur$;
 $\next$;
 loop{
  if $\cur$>0 then
   if $\cur$>max then max:=$\cur$
  else 
   if -$\cur$>max then max:=-$\cur$;;
  $\next$;  
 } 
 ret max;
}
	\end{lstlisting}
		\end{minipage}&
		\begin{minipage}[t]{0.22\textwidth}
			(b)
			\begin{lstlisting}[mathescape=true]
avg{
 sum:=$\cur$;
 cnt:=0;
 $\next$;
 loop{
  sum+=$\cur$;
  cnt+=1;
  $\next$;
 };
 ret sum/cnt;
}
			\end{lstlisting}
		\end{minipage}&
		\begin{minipage}[t]{0.35\textwidth}
			(c) 
			\begin{lstlisting}[mathescape=true]
2nd_largest {
 a:=$\cur$;
 b:=$\cur$;
 $\next$;
 if $\cur$>a then a:=$\cur$
 else b:=$\cur$;
 $\next$;
 loop{
  if $\cur$>a then b:=a;a:=$\cur$
  else if $\cur$>b then b:=$\cur$;;
  $\next$;
 }
 ret b;
}
			\end{lstlisting}		
		\end{minipage}\\
		\hline		
	\end{tabular}
	\caption{Examples of Reducers Performing Data Analytics Operations}
	\label{fig:examples}
\end{figure}

Notice that in the programming language, we only allow additions ($\addeq$) or assignments ($:=$) of a new value computed from an expression over $X^+$ to data variables. 
We argue that this is sufficient for reducers performing data analytics operations.
In Figure~\ref{fig:examples} we demonstrate a few simple examples of reducers performing data analytics operations. Observe that all of them follow the same behavioral pattern; the program iterates through the input list and aggregates the processed result in some variables. The operation used for the aggregation is usually ratter simple; it either adds a new value (like the case \texttt{avg}) or assigns a new value (like the cases {\texttt max\_abs} and {\texttt 2nd\_largest}) to the variable storing the aggregated result. Actually, the same behavioral pattern occurs in all the programs we have investigated.

The observation is actually not a big surprise. The \emph{reduce} operation in Map-Reducer has a tight relation with the \emph{fold} operation in functional languages, which aggregates the values in a list using a \emph{binary function} and returns one value. Here the data variables are used for storing the aggregated results. Since we allows only add and subtract operations in the programming language, we do not need more than ``adds/assigns a value to data variables'' to describe the binary function of fold operations. Hence we argue that our language is sufficient to describe programs that can be described by the \emph{fold} operation in functional languages (with only additions and subtractions). On the other hand, our language is more flexible than a fold operation in the sense that we have full control of what to do while iterating through the list (similar to Hadoop~\cite{Hadoop}).

\begin{figure}
\hspace{-0.4cm}
	\scalebox{0.9}{
	\begin{tabular}{|l|l|}
    \hline
	Transitions&
	Side Condition\\
    \hline
	$(y := e;p, l, \rho) \longrightarrow (p, l, \rho')$&
	$\rho'(z) =\rho(z)$ for $z\neq y$, $\rho'(y) = \sub{\rho}{e}$\\
	
	$(y \addeq e;p, l, \rho) \longrightarrow (p, l, \rho')$&
	$\rho'(z) =\rho(z)$ for $z\neq y$, $\rho'(y) = \sub{y+e}{\rho}$\\
	
	$(\ite{g}{s_1}{s_2};p, l, \rho) \longrightarrow (s_1;p, l, \rho)$&
	$\eval{g}{\rho} =\ltrue$\\
	
	$(\ite{g}{s_1}{s_2};p, l, \rho) \longrightarrow (s_2;p, l, \rho)$& $\eval{g}{\rho} =\lfalse$\\
	 
	$(\next;p, l, \rho) \longrightarrow (p, \tail(l), \rho')$&
	$\rho'(z) =\rho(z)$ for $z\neq \cur$, $\rho'(\cur) = \head(l)$, $l\neq \emptyset$\\
	
	$(x':=x;p, l, \rho) \longrightarrow (p, l, \rho')$&
	$\rho'(z) =\rho(z)$ for $z\neq x'$, $\rho'(x') = \rho(x)$\\
	
	$(\loopL{s;}\mbox{ret }r, l, \rho) \longrightarrow (s;\loopL{s;}\mbox{ret }r, l, \rho)$& \\
	
	$(\loopL{s;}\mbox{ret }r, \emptyset, \rho) \longrightarrow (\mbox{ret }r,  \emptyset, \rho)$& 	\\	
	\hline
	    
	\end{tabular}
    }
	\caption{The Semantics of the Programming Language}
	\label{fig:semantics}
\end{figure}

Formally, the semantics of a program $p_0$ in the programming language can be defined as a graph in Figure~\ref{fig:semantics}. Each node in the graph is a triple $(p,l,\rho)$, where $p$ is a program, $l$ is the input list, and $\rho$ is an valuation over $X^+\cup Y$ such that $\rho(\cur)=\head(l)$. Let $\rho_l$ be an assignment that $\rho_l(\cur)=\head(l)$, and $\rho_l(v)=\bot$ for $v\neq \cur$.
The set of initial nodes is $\{(p_0,l_0,\rho_{l_0})\mid l_0\mbox{ is an input list}\}$.
We use $p(l)$ to denote the \emph{output} of a program $p$ with respect to a list $l$. Then $p(l) =v$ if there exists a path from the initial node $(p, l, \rho_l)$ to some return node $(\mbox{ret }r,  \emptyset, \rho_r)$ and $\sub{r}{\rho_r}=v$. Otherwise, $p(l)=\bot$. Since the program is deterministic, the function $p$ is well-defined. 

We are interested in the following two decision problems:
\begin{itemize}
	\item Commutativity: given a program $p$, is it true that for all list $l$ and its permutation $l'$, $p(l) = p(l')$.
	\item Equivalence: given programs $p,p'$, is it true that for all list $l$, $p(l)=p(l')$?
\end{itemize}

One may argue that allowing only addition and subtraction is too restrictive for data analytics. For cases with multiplication and division at the return point, e.g., \texttt{avg} in Figure~\ref{fig:examples}(b), we can model them as an \emph{uninterpreted $k$-ary function}  (modeled as a tuple in our language) and still have a sound procedure for the decision problems. 





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%streaming numerical transducer%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Streaming Numerical Transducers}\label{sec-def-snt}

In this section, we introduce \emph{streaming numerical transducers} (SNTs), whose inputs are data words and outputs are integer values. Over a data word, a SNT scans the data word from left to right, records and computes information using control and data variables, and outputs a data value when it finishes reading the data word. We will use SNTs to decide the commutativity and equivalence problem of the Reduce programs defined in Section~\ref{sec-mr-prog}.


A SNT $\Ss$ is a tuple $(Q, X, Y, \delta, q_0, O)$ where 
\begin{itemize}
\item $Q$ is a finite set of states,
%
\item $X$ is a finite set of control variables to store data values that have been met,
%
\item $Y$ is a finite set of data variables to aggregate information for the output,
%
\item $\delta$ comprises the tuples $(q,  g, \eta, q')$, where $q,q'\in Q$, $g$ is a guard over $X^+$ (note that the variables from $Y$ do not occur in $g$), and $\eta$ is an assignment for $X \cup Y$, 
%
\item $q_0 \in Q$ is the initial state,
%
\item $O$ is the output function, which is a partial function from $Q$ to $\Ee_{X^+ \cup Y}$.
\end{itemize}
Moreover, we assume that the SNT $\Ss$ satisfies the following constraints.
\begin{description}
\item [1 (Deterministic).] For each pair of distinct transitions originating from $q$, say $(q, g_1, \eta_1,q'_1)$ and $(q, g_2,\eta_2,q'_2)$, it holds that $g_1 \wedge g_2$ is unsatisfiable.
%
\item [2 (Generalized flat).] Each SCC (strongly connected component) of the transition graph of $\Ss$ is either a state or a set of cycles sharing a unique state.
%
%\item[3 (Independently evolving).] For each $(q, g, \eta, q') \in \delta$ and each $y \in Y$, $\eta(y)$ contains no variables $y' \in Y$ such that $y' \neq y$.
%
\item[3 (Independently evolving and copyless).] For each $(q, g, \eta, q') \in \delta$ and for each $y \in \dom(\eta)$, $\eta(y)=e$ or $\eta(y)=y+e$ for some expression $e$ over $X^+$.
%
\end{description}

We write $q \xrightarrow{(g,\eta)} q'$ to denote $(q,g,\eta,q') \in \delta$ for convenience. 
The semantics of a SNT $\Ss$  is defined as follows. A \emph{configuration} of $\Ss$ is a pair $(q,\rho)$, where $q \in Q$ and $\rho$ is a valuation of $X \cup Y$. The \emph{initial} configuration of $\Ss$ is $(q_0,\rho_0)$, where $\rho_0(x)=\bot$ and $\rho_0(y)=\bot$ for each $x \in X$ and $y \in Y$. A sequence of configurations $(q_0,\rho_0)(q_1,\rho_1)\ldots(q_n,\rho_n)$ is
a \emph{run} of $\Ss$ over a data word $w=d_1 \dots d_n$ iff there exists a sequence of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2 \dots q_{n-1} \xrightarrow{(g_n, \eta_n)} q_n$ such that for each $i: 1 \le i \le n$, $\rho_{i-1}[d_i/\cur]  \models g_i$, and $\rho_i$ is obtained from $\rho_{i-1}$ as follows,
\begin{itemize}
\item for each $x \in X$, if $ x \in \dom(\eta_i)$, then $\rho_i(x)=d_i$, otherwise, $\rho_i(x)=\rho_{i-1}(x)$,
%
\item for each $y \in Y$, if $y \in \dom(\eta_i)$, then $\rho_i(y)=(\rho_{i-1}[d_i/\cur])(\eta_i(y))$, otherwise, $\rho_i(y)=\rho_{i-1}(y)$,
\end{itemize}
We will call $(q_n,\rho_n)$ as the \emph{final configuration} of the run.
We would like to remark that for each data word $w$, there is at most one run of $\Ss$ over $w$, since $\Ss$ is deterministic. 

Over a data word $w = d_1 \dots d_n$, if there is a run of $\Ss$ over $w$ with the final configuration $(q_n,\rho_n)$, and $O(q_n)$ is defined, then the output of $\Ss$ over $w$, denoted by ${\Ss}(w)$, is $\eval{O(q_n)}{\rho_n}$. Otherwise, ${\Ss}(w)$ is $\bot$.

\begin{example}[SNT for max and sum]
The SNT to define the maximum of the integers occurring in a data word is given by $\Ss_{\max}=(\{q_0,q_1\}, \{\maxv\}, \emptyset, \delta, q_0, O)$  such that $\delta = \{(q_0, \ltrue, \maxv:=\cur, q_1), (q_1, \maxv < \cur, \maxv:=\cur,q_1), (q_1, \maxv \ge \cur, \eta_\bot, q_1)\}$, and $O(q_1)=\maxv$, where $\maxv:=\cur$ denotes the function that assigns $\cur$ to $\maxv$, and $\eta_\bot$ denotes the assignment function of the empty domain. The SNT to define the sum of the integers occurring in a data word is given by $\Ss_{\mathrm{sum}}=(\{q_0,q_1\}, \emptyset, \{\sumv\}, \delta, q_0, O)$ such that $\delta=\{(q_0, \ltrue, \sumv:=\cur, q_1), (q_1, \ltrue, \sumv:=\sumv + \cur, q_1)$, and $O(q_1)=\sumv$. 
\end{example}

\begin{proposition}\label{prop-mrprog-to-snt}
For each reducer program $p$, an equivalent SNT $\Ss$ (w.r.t. the commutativity and equivalence problems) can be constructed.
\end{proposition}

The main difference between $p$ and $\Ss$ is that several transitions in the semantic graph of $P$ correspond to one transition in $\Ss$. A reducer program moves to the next input only when a $\next$ statement is encountered while a SNT reads one input symbol in one transition. Based on this observation, we give a work-list algorithm translating a program $P$ to an SNT $\Ss$ in algorithm~\ref{fig:reducer2SNT} the appendix.


%\begin{example}[Example inspired by Pagerank]
%The following transducer sum all the data values, except the last position, then it outputs a concatenation of the sum and the last tuple: $(q_0, 1, true, sum:= sum + p_1, q_0)$, $(q_0, k, true, (x_i:=p_i)_{1 \le i \le k}, q_1)$, $O(q_1)=(sum, x_1,\dots, x_k)$.
%\end{example}



%We first compute a fixed point $\defval$ inductively as follows. 
%\begin{enumerate}
%\item Initially, let $\defval_0=\{(q_0,\emptyset)\}$.
%
%\item For each $i > 0$, compute $\defval_i$ from $\defval_{i-1}$ as follows,
%\begin{itemize}
%\item each element of $\defval_{i-1}$ is an element of $\defval_i$, 
%
%\item for each $(q,Z) \in \defval_{i-1}$ and each transition $(q,g,\eta,q') \in \delta$,  let $Z' = Z \cup (X \cap \dom(\eta)) \cup \{y \in Y \cap \dom(\eta) \mid \vars(\eta(y)) \subseteq Z \cup \{\cur\}\}$, put $(q',Z')$ into $\defval_i$.
%\end{itemize}
%
%\item If $\defval_{i-1}=\defval_i$, then the computation stops, otherwise, let $i:=i+1$ and the computation continues.
%\end{enumerate}




We focus on the following three decision problems of SNTs in this paper, the commutativity problem, the equivalence problem, and the non-zero output problem.
\begin{description}
\item[(Commutativity).] Given a SNT $\Ss$, decide whether $\Ss$ is commutative, that is, whether for each data word $w$ and each permutation $w'$ of $w$, the output of $\Ss$ over $w$ is equal to that of $\Ss$ over $w'$.
%
\item[(Equivalence).] Given two SNTs $\Ss_1,\Ss_2$, decide whether $\Ss_1$ and $\Ss_2$ are equivalent, that is, whether over each data word $w$, $O_{\Ss_1}(w)=O_{\Ss_2}(w)$.
%
\item[(Non-zero output).] Given a SNT $\Ss$, decide whether $\Ss$ has a non-zero output, that is, whether there is an input $w$ such that $O_{\Ss}(w) \neq \bot$ and $O_{\Ss}(w)$ is non-zero. 
\end{description}
In the following, we show that the commutativity problem can be reduced to the equivalence problem, which in turn can be reduced to the non-zero output problem.


\begin{proposition}\label{prop-snt-cmm-to-eqv}
The commutativity problem of SNTs is reduced to the equivalence problem of SNTs in exponential time. 
\end{proposition}

The equivalence problem of SNTs can be further reduced to the non-zero output problem of SNTs.

\begin{proposition}\label{prop-snt-eqv-to-nzero}
From SNT $\Ss_1$ and $\Ss_2$, a SNT $\Ss_3$ can be constructed in polynomial time such that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss_3$ over $w$ is nonzero. 
\end{proposition}

We introduce a concept of ``well-defined'' for SNTs. Let $\Ss=(Q,X,Y,\delta,q_0,O)$ be an SNT. Then $\Ss$ is said to be \emph{well-defined} if for each data word $w=d_1\dots d_n$ and each run of $\Ss$ over $w$, say  $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \dots q_{n-1} \xrightarrow{g_n,\eta_n} q_n$, let $(q_0,\rho_0),\dots,(q_n,\rho_n)$ be the resulting sequence of configurations, then the following conditions hold: for each $i: 1 \le i \le n$ and each $z \in X \cup Y$ occurring in $(g_i,\eta_i)$, we have $\rho_{i-1}(z) \neq \bot$, moreover, if $O(q_n)$ is defined, then for each variable $z$ occurring in $O(q_n)$, we have $\rho_{n}(z) \neq \bot$.

From now on, we assume that all SNTs are well-defined. Otherwise, we can construct an equivalent well-defined SNT $\Ss'=(Q', X,Y, \delta', (q_0,\emptyset), O')$, where 
\begin{itemize}
	\item $Q' = Q \times 2^X$,
	%
	\item $\delta'$ comprises the tuples $((q,Z),g,\eta,(q', Z'))$ such that $(q,g,\eta,q') \in \delta$ and $Z' = Z \cup (X \cap \dom(\eta)) \cup \{y \in Y \cap \dom(\eta) \mid \vars(\eta(y)) \subseteq Z \cup \{\cur\}\}$ (intuitively, suppose that the values of the variables from $Z$ are defined before a transition $(q,g,\eta,q')$, then $Z'$ is the set of variables whose values are defined after applying the transition),
	%
	\item for each $(q,Z) \in Q'$, if $O(q)$ is defined and $\vars(O(q)) \subseteq Z$, then $O'((q,Z))=O(q)$, otherwise, $O((q,Z))$ is undefined.
\end{itemize}

Note that if a SNT $\Ss$ is well-defined, then for each data word $w$, if the run of $\Ss$ over a data word $w$ reaches a state $q$ and $O(q)$ is defined, then the output of $\Ss$ over $w$ is defined.

We first assume that the guards of the transitions do not contain the comparisons with integer constants and illustrate the main ideas of the decision procedure as follows.
\begin{enumerate}
	\item  We first show how to summarize the computations over paths and cycles. 
	%
	\item We present an algorithm to decide the non-zero output problem for the situation that the transition graph of the given SNT  is a generalized lasso. A \emph{generalized lasso} is an extension of lasso where the cycle is replaced by a collection of cycles such that there is a state $q$ which is the unique common state of each pair of distinct cycles.
	%
	\item We demonstrate how to extend the algorithm to the more general situation that the transition graph of the given SNT is generalized flat.
\end{enumerate}
Finally, we will show how to adapt the algorithm for the situation that the guards of the transitions may contain the comparisons with integer constants.

At first, we normalize the SNTs in order to facilitate the presentation of the decision procedure.

Suppose $\Ss=(Q,X,Y,\delta,q_0,O)$ is a SNT. Let $c_{min}$ and $c_{max}$ denote the minimum resp. maximum integer constant occurring in the guards of the transitions of $\Ss$. 

A SNT $\Ss=(Q,X,Y,\delta,q_0,O)$ is said to be \emph{normalized} if the following two constraints are satisfied.
\begin{itemize}
	\item For each $(q,g,\eta,q') \in \delta$, if $\eta(x)=\cur$ for some $x \in X$, then the guard $g$ implies $\bigwedge \limits_{x \in X} \cur \neq x$.  Intuitively, when the current data value is stored into some control variable, it is required that the data value is distinct from all the data values that have already been stored in the control variables.
	%
	\item For each $(q, g, \eta, q') \in \delta$, the guard $g$ includes one of the following formulae as a conjunct: $\cur < c_{min}$, or $\cur = c$ for $c_{min} \le c \le c_{max}$, or $\cur > c_{max}$.
\end{itemize}


\begin{proposition}\label{prop-snt-norm}
	From each SNT, an equivalent normalized SNT can be constructed in exponential time. 
\end{proposition}

From now on, we assume that all SNTs are normalized. 

\section{Decision procedure for the non-zero output problem}\label{sec-dec-snt}

Our goal in this section is to present a decision procedure for the non-zero output problem of normalized SNTs.  In the following, we fix a normalized SNT $\Ss = (Q,X,Y,\delta,q_0,O)$ such that $X=\{ x_1,\dots, x_k\}$ and $Y = \{y_1,\dots,y_l\}$. We illustrate the main ideas of the decision procedure for the situation that the guards in the transitions are constant-free, that is, the guards contain no comparisons with constants. The discussions of the more general situation are migrated to the appendix. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Summarization of the computations on paths and cycles}

Suppose $P=p_0 \xrightarrow{(g_1,\eta_1)} p_1 \dots p_{n-1} \xrightarrow{(g_n,\eta_n)} p_{n}$ is a path in $\Ss$. 

Suppose that the initial values of the $k$ control variables are represented by $d_1,\dots, d_k$ and the $n$ data values met when traversing the path are represented by $d_{k+1},\dots,d_{k+n}$ (these data values may repeat). Then the guards and the assignments in the path induce an equivalence relation $\sim$ on $\{1,\dots, k+n\}$ so that  $i \sim j$ iff it can be inferred from the guards and assignments that $d_i = d_j$. Since $\Ss$ is normalized, we know that for each pair of indices $i,j: 1 \le i < j \le k+n$ such that $i \sim j$, it holds that $j \ge k+1$. Let $I_1,\dots, I_{k+r}$ be an enumeration of the equivalence classes of $\sim$ on $\{1,\dots, k+n\}$ such that $\min(I_1) < \dots < \min(I_{k+r})$. Then for each $j: 1 \le j \le k$, $\min(I_j)=j$.

Suppose that the initial values of the $k$ control variables are denoted by the variables $d^{(0)}_1,\dots,d^{(0)}_k$ respectively. Moreover, suppose that the $r$ fresh data values that are introduced when traversing the path are denoted by the variables $d^{(1)}_{1},\dots,d^{(1)}_{r}$, with one data value for each of $I_{1},\dots,I_{r}$. 
In addition, suppose that the initial values of $y_1,\dots, y_l$ are denoted by the variables $o_1,\dots,o_l$ respectively. 

\begin{proposition}\label{prop-sum-path}
The values of the control and data variables after traversing the path $P$ are specified by a function $\chi$ satisfying the following conditions.
\begin{itemize}
\item There is an injective mapping $\pi: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi(j) \le k$, then $\pi(j)=j$ and $\chi(x_j)=d^{(0)}_{j}$, otherwise, $\chi(x_j)=d^{(1)}_{\pi(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi(y_j) = \cste_{j} + \cstl_j \varo_j + \csta_{j,1} \vard^{(0)}_1 + \dots + \csta_{j,k} \vard^{(0)}_k + \cstb_{j,1} \vare^{(1)}_1 +\dots + \cstb_{j,r} \vare^{(1)}_{r}$ for some constants $\alpha_{j,0},\alpha_{j,1}, \beta_{j,1},\dots,\beta_{j,k}, \gamma_{j,1},\dots,\gamma_{j,r}$ such that $\alpha_{j,1} \in \{0,+1\}$ (as a result of the ``independently evolving and copyless'' constraint).
\end{itemize}
\end{proposition}

\hide{\\
	
$^P_3 d^{y_j}_{j'}$	

$d^{P,y_j,3}_{{\pi^P}^{-1}(j')}$
$d(P,y_j,3)_{{\pi(P)}^{-1}(j')}$
$^P_3{\mathfrak{d}^j_{j'}}$
$\prescript{P}{3}{\mathfrak{d}^j_{j'}}$
\newcommand\va{\mathfrak{a}}
\newcommand\vb{\mathfrak{b}}
\newcommand\vd{\mathfrak{d}}


	
\begin{proposition}\label{prop-sum-path}
	The values of the control and data variables after traversing the path $P$ are specified by a function $\chi^P$ satisfying the following conditions.
	\begin{itemize}
		\item There is an injective mapping $\pi^P: \{1,\dots,k\} \rightarrow \{1,\dots, k+r_P\}$ such that for each $x_j \in X$, if $\pi^P(j) \le k$, then $\pi^P(j)=j$ and $\chi^P(x_j)=\vb_{j}$, otherwise, $\chi(x_j)=\vd_{\pi^P(j)-k}$.
		% 
		\item For each $y_j \in Y$, $\chi^P(y_j) = {c}^P + a^P\va^P + b^{P,y_j}_{1} \vb^P_1 + \dots + b^{P,y_j}_{k} \vb_k + d_{j,1} \vd_1 +\dots + d_{j,r_P} \vd_{r_P}$ for such that $a \in \{0,+1\}$ (as a result of the ``independently evolving and copyless'' constraint).
		
		\item test for cycles: $\chi^{C^3}(y_j) = {c}^{C^3} + a^{C^3}\va^{C^3} + b^{{C^3},y_j}_{1} \vb^{C^3}_1 + \dots + b^{{C^3},y_j}_{k} \vb_k + d_{j,1} \vd_1 +\dots + d_{j,r_C} \vd_{r_C}$
	\end{itemize}
\end{proposition}	



}


Suppose $\{d^{(0)}_1,\dots,d^{(0)}_k, o_1,\dots,o_l, d^{(1,1)}_1,\dots,d^{(1,1)}_{r_1}, d^{(2,1)}_1,\dots,d^{(2,1)}_{r_2}\}$ are a set of pairwise distinct variables from $\intvars$. For $b=1,2$, let 
\[\Zz_b=\{d^{(0)}_1,\dots,d^{(0)}_k, o_1,\dots,o_l, d^{(b,1)}_1,\dots,d^{(b,1)}_{r_b}\},\] and $\chi_b$ be a function from $X \cup Y$ to $\Ee_{\mathcal{Z}_b}$. Then the \emph{composition} of $\chi_1$ and $\chi_2$, denoted by $\chi_1 \circ \chi_2$, is defined as follows: Let $\chi'_1$ be a function with the domain $\{d^{(0)}_1,\dots,d^{(0)}_k, o_1,\dots,o_l\}$ such that for each $j: 1 \le j \le k$ (resp. $j: 1 \le j \le l$), $\chi'_1(d^{(0)}_j)=\chi_1(x_j)$ (resp. $\chi'_1(o_j)=\chi_1(y_j)$). Then
\begin{itemize}
\item for each $x_j \in X$, if $\chi_2(x_j) = d^{(0)}_j$, then $(\chi_1 \circ \chi_2)(x_j)=\chi'_1(\chi_2(x_j)) = \chi'_1(d^{(0)}_j)=\chi_1(x_j)$, otherwise, $(\chi_1 \circ \chi_2)(x_j)=\chi_2(x_j)$,
%
\item for each $y_j \in Y$, $(\chi_1 \circ \chi_2)(y_j)=\chi'_1(\chi_2(y_j))$.
\end{itemize}

\begin{corollary}\label{cor-comp-two-paths}
Suppose that $P_1$ and $P_2$ are two paths in $\Ss$ such that $p^{(1)}_{n_1}=p^{(2)}_0$. Moreover, let $\chi_1$ (resp. $\chi_2$) be the function summarizing the computation of $\Ss$ on $P_1$ (resp. $P_2$). Then the function summarizing the computation of $\Ss$ over the path $P_1 P_2$ is $\chi_1 \circ \chi_2$.
\end{corollary}

In order to get a better understanding of the relationship between $(\chi_1 \circ \chi_2)$ and $\chi_1,\chi_2$, we apply a refined analysis of $\chi_1 \circ \chi_2$ in the following. 

From Proposition~\ref{prop-sum-path}, for $b=1,2$, we assume that $\chi_b$ is defined as follows.
\begin{itemize}
\item There is an injective mapping $\pi_b: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi_b(j) \le k$, then $\pi_b(j)=j$ and $\chi_b(x_j)=d^{(0)}_{j}$, otherwise, $\chi_b(x_j)=d^{(b,1)}_{\pi_b(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi_b(y_j) = \alpha^{(b)}_{j,0} + \alpha^{(b)}_{j,1} o_j + \beta^{(b)}_{j,1} d^{(0)}_1 + \dots + \beta^{(b)}_{j,k} d^{(0)}_k + \gamma^{(b)}_{j,1} d^{(b,1)}_1 +\dots + \gamma^{(b)}_{j,r_b} d^{(b,1)}_{r_b}$ such that $\alpha^{(b)}_{j,1} \in \{0,+1\}$.
\end{itemize}

Then
for each $y_j \in Y$,
\[
\begin{array}{l c l}
\medskip
(\chi_1 \circ \chi_2)(y_j) & = & \chi'_1(\chi_2(y_j))\\
%& = & \chi'_1(\alpha^{(2)}_{j,0} + \alpha^{(2)}_{j,1} o_j + \beta^{(2)}_{j,1} d^{(0)}_1 + \dots + \beta^{(2)}_{j,k} d^{(0)}_k + \\
%& & \hspace{8mm} \gamma^{(2)}_{j,1} d^{(2,1)}_1 +\dots + \gamma^{(2)}_{j,r_2} d^{(2,1)}_{r_2})\\
%
& = &  \alpha^{(2)}_{j,0} + \alpha^{(2)}_{j,1} \chi_1(y_j) + \beta^{(2)}_{j,1} \chi_1(x_1) + \dots + \beta^{(2)}_{j,k} \chi_1(x_k) +\\
\medskip
& & \gamma^{(2)}_{j,1} d^{(2,1)}_1 +\dots + \gamma^{(2)}_{j,r_2} d^{(2,1)}_{r_2} \\
%
& =  & (\alpha^{(2)}_{j,0}+\alpha^{(2)}_{j,1} \alpha^{(1)}_{j,0})+ (\alpha^{(2)}_{j,1}\alpha^{(1)}_{j,0}) o_j + \\
%
& & \sum \limits_{j' \le k, \pi_1(j')=j'} (\beta^{(2)}_{j,j'}+\alpha^{(2)}_{j,1} \beta^{(1)}_{j,j'}) d^{(0)}_{j'} + \sum \limits_{j' \le k, \pi_1(j') \neq j'} (\alpha^{(2)}_{j,1} \beta^{(1)}_{j,j'}) d^{(0)}_{j'}  \\
%
& & + \sum \limits_{j' \le r_1, j' + k \in \rng(\pi_1)} (\beta^{(2)}_{j,\pi_1^{-1}(j'+k)}+\alpha^{(2)}_{j,1} \gamma^{(1)}_{j,j'}) d^{(1,1)}_{j'} +\\
%
& & \sum \limits_{j' \le r_1, j' + k \not \in \rng(\pi_1)} (\alpha^{(2)}_{j,1} \gamma^{(1)}_{j,j'}) d^{(1,1)}_{j'} + 
 \gamma^{(2)}_{j,1} d^{(2,1)}_1 +\dots + \gamma^{(2)}_{j,r_2} d^{(2,1)}_{r_2}.
\end{array}
\] 

In the following, for each path $P=C^{\ell}$ which is obtained by iterating a cycle $C$ for $\ell$ times, we provide an analysis of the computation of $\Ss$ on $P$.

Suppose that $C$ is a cycle in $\Ss$, that is, a path $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \dots q_{n-1} \xrightarrow{(g_n, \eta_n)} q_n$ such that $q_n = q_0$.  

Suppose the initial values of the $k$ control variables are $d^{(0)}_1,\dots,d^{(0)}_k$. Moreover, suppose that the $r_C$ data values $d^{(C,1)}_{1},\dots,d^{(C,1)}_{r_C}$ are introduced when traversing the cycle for the first time. 
In addition, suppose that the initial values of $y_1,\dots, y_l$ are $o_1,\dots,o_l$. 

From Proposition~\ref{prop-sum-path}, we know that a function $\chi_C$ can be constructed to summarize the computation of $\Ss$ on $C$.
\begin{itemize}
\item There is an injective mapping $\pi_C: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi_C(j) \le k$, then $\pi_C(j)=j$ and $\chi_C(x_j)=d^{(0)}_{j}$, otherwise, $\chi_C(x_j)=d^{(C,1)}_{\pi_C(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi_C(y_j) = \alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} o_j + \beta^{(C)}_{j,1} d^{(0)}_1 + \dots + \beta^{(C)}_{j,k} d^{(0)}_k + \gamma^{(C)}_{j,1} d^{(C,1)}_1 +\dots + \gamma^{(C)}_{j,r_C} d^{(C,1)}_{r_C}$ such that $\alpha^{(C)}_{j,1} \in \{0,+1\}$.
\end{itemize}

\begin{proposition}\label{prop-sum-cycle}
Suppose $P=C^{\ell}$ such that $\ell \ge 2$. Then the function $\chi^{(C)}_{\ell}$ to summarize the computation of $\Ss$ on $P$ is defined as follows,
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0}+ \dots +(\alpha^{(C)}_{j,1})^{\ell-1} \alpha^{(C)}_{j,0}) + (\alpha^{(C)}_{j,1})^\ell o_j + \\
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1}\beta^{(C)}_{j,j'} + \dots +(\alpha^{(C)}_{j,1})^{\ell-1}  \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \\
%
& & \sum \limits_{j'\le k, \pi_C(j') \neq j'} ((\alpha^{(C)}_{j,1})^{\ell-1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( (\alpha^{(C)}_{j,1})^{\ell-2} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +(\alpha^{(C)}_{j,1})^{\ell-1}\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} ((\alpha^{(C)}_{j,1})^{\ell-1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1}\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C},
\end{array} 
\]
where $d^{(C,2)}_{1},\dots, d^{(C,2)}_{r_C},\dots, d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$
 are the data values introduced when traversing $C$ for the second time, $\dots$, and for $\ell$ times.
\end{proposition}

From Proposition~\ref{prop-sum-cycle} and the fact that $\alpha_{j,1} \in \{0,+1\}$, for $\ell \ge 2$, we deduce the following facts.
\begin{itemize}
\item If $\alpha^{(C)}_{j,1}=0$, then
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & \alpha^{(C)}_{j,0} +  \sum \limits_{j' \le k, \pi_C(j')=j'} \beta^{(C)}_{j,j'} d^{(0)}_{j'} +
\\
\smallskip
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} d^{(C,\ell-1)}_{j'} + \\
& & \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
\item If $\alpha^{(C)}_{j,1}=1$, then 
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} \ell) + o_j +   \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'} \ell) d^{(0)}_{j'} + \sum \limits_{j'\le k, \pi_C(j') \neq j'} \beta^{(C)}_{j,j'} d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)} + \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} \gamma^{(C)}_{j,j'} d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} \gamma^{(C)}_{j,j'} d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
%
\hide{
\item If $\alpha^{(C)}_{j,1}=-1$ and $\ell$ is even, then
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = &  o_j + \sum \limits_{j'\le k, \pi_C(j') \neq j'} (-\beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} - \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (-\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
\item If $\alpha_{j,1}=-1$ and $\ell$ is odd, then
\[
\begin{array}{l c l}
\smallskip
\chi^{(C)}_{\ell}(y_j)  & = &  \alpha^{(C)}_{j,0} - o_j + \sum \limits_{j' \le k, \pi_C(j')=j'} \beta^{(C)}_{j,j'} d^{(0)}_{j'} +  \sum \limits_{j'\le k, \pi_C(j') \neq j'}  \beta^{(C)}_{j,j'} d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( -\beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} \gamma^{(C)}_{j,j'} d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
}
\end{itemize}
%
From the analysis above, we observe that in $\chi^{(C)}_\ell(y_j)$, 
\begin{itemize}
\item the constant coefficient is either $\alpha^{(C)}_{j,0}$, or $\alpha^{(C)}_{j,0} \ell$, 
%
\item the coefficient of $o_j$ is $0$, or $1$, 
%
\item for each data value $d^{(0)}_{j'}$, the coefficient of $d^{(0)}_{j'}$ is either $\beta^{(C)}_{j,j'}$, or $0$, or $\beta^{(C)}_{j,j'} \ell$,
%
\item for each data value $d^{(C,i)}_{j'}$ with $i \ge 1$, the coefficient of $d^{(C,i)}_{j'}$ is either $0$, or $\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}$, or $\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\gamma^{(C)}_{j,j'}$, or $\gamma^{(C)}_{j,j'}$.
\end{itemize}


\subsection{Decision procedure for generalized lassos}

In this subsection, we present a decision procedure for the situation that the transition graph of $\Ss$ is a generalized lasso. 

Suppose the transition graph of $\Ss$ comprises a handle $H=q_0 q_1 \dots q_m$ and a collection of simple cycles $C_1,\dots,C_n$ which share the unique state $q_m$. Moreover, without loss of generality, we assume that $O(q_m) = a_0 + a_1 x_1 + \dots + a_k x_k + b_1 y_1 + \dots + b_l y_l$, and $O(q)$ is undefined for all the other states $q$.

From Proposition~\ref{prop-sum-path}, we know that a function $\chi_H$ can be constructed to summarize the computation of $\Ss$ on the handle. Let $d^{(0)}_{1}, \dots, d^{(0)}_{r_H}$ denote the $r_H$ data values introduced in the handle. Because all the values of the control and data variables are $\bot$ (undefined) in the initial configuration,  we can concretize $\chi_H$ as follows. 
\begin{itemize}
\item There is an injective mapping $\pi_H: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi_H(j) \le k$, then $\pi_H(j)=j$ and $\chi_H(x_j)=\bot$, otherwise, $\chi_H(x_j)=d^{(0)}_{\pi_H(j)-k}$. Without loss of generality, we assume $\pi_H(j) > k$ for each $j: 1\le j \le k$. Intuitively, this means that after traversing the handle $H$, the values of all control variables are defined (i.e. not $\bot$).
% 
\item For each $y_j \in Y$, $\chi_H(y_j) = \alpha^{(H)}_{j,0} + \alpha^{(H)}_{j,1} o_j + \gamma^{(H)}_{j,1} d^{(0)}_1 +\dots + \gamma^{(H)}_{j,r_H} d^{(0)}_{r_H}$ such that $\alpha^{(H)}_{j,1} \in \{0,+1,-1\}$. Since the initial value of the control variable $y_j$ is $o_j=\bot$, we assume that $\alpha^{(H)}_{j,1}=0$, without loss of generality.
\end{itemize}

Moreover, from Proposition~\ref{prop-sum-cycle}, we know that for each cycle $C_i$ ($1 \le i \le n$), a function $\chi^{(C_i)}_{\ell}$ can be constructed to summarize the computation of $\Ss$ on $C^{\ell}_i$ (the iteration of $C_i$ for $\ell$ times).

A \emph{cycle scheme} $\schm$ is a path $H C_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that $i_1,\dots,i_t \in \{1,\dots,n\}$, $\ell_1,\dots, \ell_t \ge 1$, and for each $j: 1 \le j < t$, $i_j \neq i_{j+1}$. Intuitively, $\schm$ is a path obtained by traversing $H$ first, then iterating $C_{i_1}$ for $\ell_1$ times, $C_{i_2}$ for $\ell_2$ times, and so on. From Corollary~\ref{cor-comp-two-paths}, we know that a function $\chi_{\schm}$ can be constructed by composing $\chi_{H}, \chi^{(C_{i_1})}_{\ell_1},\dots,\chi^{(C_{i_t})}_{\ell_t}$, to summarize the computation of $\Ss$ on $\schm$.

\begin{proposition}\label{prop-cycle-schm}
Let $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ be a cycle scheme. Then for each $j'$ such that $j' \le k$ and $\pi_{C_{i_1}}(j')=j'$, $\chi_{\schm}(O(q_m))$ contains the following expression,
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) d^{(0)}_{\pi_H(j')-k}. 
\]
Moreover, the constant coefficient of $\chi_\schm(O(q_m))$ contains the following expression,
\[
\sum \limits_{1 \le j \le l} 
%\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) 
%\\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \alpha^{(C_{i_1})}_{j,0}.
%\end{array}
\]
\end{proposition}

\begin{proof}
At first,  let us check $\chi^{(C_{i_1})}_{\ell_1}(O(q_m))$.
\[
\begin{array}{l c l}
\chi^{(C_{i_1})}_{\ell_1}(O(q_m)) & = & a_0 + a_1 \chi^{(C_{i_1})}_{\ell_1}(x_1) + \dots a_k \chi^{(C_{i_1})}_{\ell_1}(x_k) + \\
& & b_1 \chi^{(C_{i_1})}_{\ell_1}(y_1) + \dots + b_l \chi^{(C_{i_1})}_{\ell_1}(y_l).
\end{array}
\] 

Then $\chi^{(C_{i_1})}_{\ell_1}(O(q_m))$ is a linear combination of the variables $d^{(0)}_1,\dots, d^{(0)}_{r_H}$ and $d^{(C_{i_1},1)}_1,\dots, d^{(C_{i_1},1)}_{r_{C_{i_1}}}, \dots, d^{(C_{i_1},\ell_1)}_1,\dots, d^{(C_{i_1},\ell_1)}_{r_{C_{i_1}}}$.

For each $j'$ such that $j' \le k$ and $\pi_{C_{i_1}}(j')=j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ in $\chi^{(C_{i_1})}_{\ell_1}(O(q_m))$ is 

\[a_{j'} + \sum \limits_{1 \le j \le l} b_j \left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}.\]
%
%
For each $j: 1 \le j \le l$, $\chi_{\schm}(y_j)$ contains the following expression 
\[\left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right)\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'} d^{(0)}_{\pi_H(j')-k}.\]

Since 
\[
\chi_{\schm}(O(q_m)) = a_0 + a_1 \chi_{\schm}(x_1) + \dots a_k \chi_{\schm}(x_k) + b_1 \chi_{\schm}(y_1) + \dots + b_l \chi_{\schm}(y_l),
\] 
it is not hard to see that $\chi_\schm(O(q_m))$ contains the expression,
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) d^{(0)}_{\pi_H(j')-k}. 
\]
The argument for the constant coefficient is similar.
\qed
\end{proof}

We are ready to present the decision procedure.

\smallskip

\noindent {\bf Step I}. Decide whether $\chi_H(O(q_m))$ is not identical to zero (it is easy to do so, just check the coefficients of $d^{(0)}_1, \dots, d^{(0)}_{r_H}$). If the answer is yes, then the decision procedure terminates and returns the answer $\ltrue$. Otherwise, go to Step II. \qed

\smallskip

\noindent {\bf Step II}. For each cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$, from Proposition~\ref{prop-cycle-schm}, we know that $\chi_{\schm}(O(q_m))$ contains the following expression,
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) d^{(0)}_{\pi_H(j')-k}. \ \ \  (\ast)
\]
Since $\alpha^{(C_{i_2})}_{j,1}, \dots, \alpha^{(C_{i_t})}_{j,1} \in \{0,+1\}$, the expression $(\ast)$ is of the form 
\[
\sum \limits_{1 \le j \le l} b_j  s_{\schm,j} \left(1+\alpha^{(C_{i_1})}_{j,1} + \dots +(\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'},
\]
where $s_{\schm,j} \in \{0,+1\}$. Then the expression $(\ast)$ can be rewritten as $\mu_{\schm, (i_1,j')} \ell_1 + \nu_{\schm, (i_1,j')}$ for some integer constant $\mu_{\schm, (i_1,j')},\nu_{\schm, (i_1,j')}$ (possibly $\mu_{\schm, (i_1,j')}=0$). 

For each $i_1: 1 \le i_1 \le n$, if there are a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$  and $j'$ such that 
\begin{itemize}
\item $i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
\item $j' \le k$, $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$, 
\end{itemize}
then return $\ltrue$.

Similarly, if there is a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that 
$i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
and $\mu_{\schm,(i_1,0)} \neq 0$, 
%
then return $\ltrue$, where $\mu_{\schm,(i_1,0)}$ is obtained from 
\[
\sum \limits_{1 \le j \le l} 
%\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) 
%\\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \alpha^{(C_{i_1})}_{j,0},
%\end{array}
\]
similarly to $\mu_{\schm,(i_1,j')}$ above.

If the decision procedure has not return yet, then go to Step III. \qed

\smallskip

Note that for a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that $j' \le k$, $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$, we can let $d^{(0)}_{\pi_H(j')-k} \neq 0$, and let $\ell_1$ sufficiently large, so that $(\mu_{\schm,(i_1,j')} \ell_1 + \nu_{\schm,(i_1,j')})d^{(0)}_{\pi_H(j')-k}$ dominates $\chi_{\schm}(O(q_m))$, and  $\chi_{\schm}(O(q_m))$ becomes non-zero. Similarly for $\mu_{\schm,(i_1,0)} \ell_1 + \nu_{\schm,(i_1,0)}$.

We would like to remark that although in Step II, we do not consider all the cycle schemes, the set of cycle schemes chosen in Step II does exhaust all the possible values of $s_{\schm,j}$ when $\schm$ varies.


\medskip

\noindent {\bf Claim}. 
{\it 
Suppose the decision procedure has not returned yet after Step II. For each cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$, each $s: 1 \le s \le t$, and each $y_j \in Y$, let $(\chi^{(\Cc_{i_s})}_{\ell_s})'(y_j)$ denote the expression obtained by removing from $\chi^{(\Cc_{i_s})}_{\ell_s}(y_j)$  all the expressions of the form $c\ \ell_s$ (where $c$ is an integer constant).  Moreover, let $\chi'_\schm$ be the composition of $\chi_H$, $(\chi^{(\Cc_{i_1})}_{\ell_1})'$, $\dots$, and $\chi^{(\Cc_{i_t})}_{\ell_t})'$. Then the following two facts hold.
\begin{enumerate}
\item There is an assignment of values to the variables such that $\chi_\schm(O(q_m))$ becomes non-zero iff there is an assignment of values to the variables such that $\chi'_\schm(O(q_m))$ becomes non-zero.
%
\item All the coefficients in $\chi'_\schm(y_j)$ (where $y_j \in Y$) are from a bounded domain $D$, no matter whatever $\schm$ is. Moreover a finite state automaton $\Aa$ can be constructed from $\chi_H,\chi_{C_1},\dots,\chi_{C_n}$ to record the evolvement of these coefficients  in the cycle schemes.
\end{enumerate}
}

\begin{proof}
Because Step II has already considered the evolvement of the coefficients of $d^{(0)}_{\pi_H(j')-k}$ by varying the cycle scheme $\schm$, it is not hard to get the first fact.

We prove the second fact in the following. We exemplify the proof for $t=2$. 
For each $y_j \in Y$, we will illustrate the argument for the situation that $\alpha^{(C_{i_1})}_{j,1} = 1$ and $\alpha^{(C_{i_2})}_{j,1} = 1$.

Suppose $\alpha^{(C_{i_1})}_{j,1} = 1$ and $\alpha^{(C_{i_2})}_{j,1} = 1$. Then in $\chi'_\schm(y_j)$,
\begin{itemize}
\item the constant coefficient is $0 + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\  0 = 0$ (here $\alpha^{(C_{i_2})}_{j,0} \ell_2$ and $\alpha^{(C_{i_1})}_{j,0} \ell_1$ are removed),
%
%\item the coefficient of $o_j$ is $1$,
%
\item for each $j' \le r_{H}$ such that $j' \not \in \{\pi_H(j'')-k \mid 1 \le j'' \le k\}$, the coefficient of $d^{(0)}_{j'}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(H)}_{j'} = \gamma^{(H)}_{j'}$,
%
\item for each $j' \le k$ such that $\pi_{C_{i_1}}(j') = j'$ and $\pi_{C_{i_2}}(j') = j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ is $0 + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\ 0 = 0$ (here $\beta^{(C_{i_2})}_{j,j'} \ell_2$ and $\beta^{(C_{i_1})}_{j,j'} \ell_1$ are removed),
%
\item for each $j' \le k$ such that $\pi_{C_{i_1}}(j') = j'$ and $\pi_{C_{i_2}}(j') \neq j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ is $\beta^{(C_{i_2})}_{j,j'} + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\ 0 = \beta^{(C_{i_2})}_{j,j'}$ (here $\beta^{(C_{i_1})}_{j,j'} \ell_1$ is removed),
%
\item for each $j' \le k$ such that $\pi_{C_{i_1}}(j') \neq j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\ \beta^{(C_{i_1})}_{j,j'} = \beta^{(C_{i_1})}_{j,j'}$,
%
\item if $\ell_1>1$, then for each $j' \le r_{C_{i_1}}$ such that $j'+k \in \rng(\pi_{C_{i_1}})$ and each $i: 1 \le i < \ell_1$, the coefficient of $d^{(C_{i_1},i)}_{j'}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} (\beta^{(C_{i_1})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)}+\gamma^{(C_{i_1})}_{j,j'}) = \beta^{(C_{i_1})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)}+\gamma^{(C_{i_1})}_{j,j'}$,
%
\item if $\ell_1>1$, then for each $j' \le r_{C_{i_1}}$ such that $j'+k \not \in \rng(\pi_{C_{i_1}})$ and each $i: 1 \le i < \ell_1$, the coefficient of $d^{(C_{i_1},i)}_{j'}$ is the expression $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'} = \gamma^{(C_{i_1})}_{j,j'}$,
%
\item for each $ j' \le r_{C_{i_1}}$ such that $j'+k \in \rng(\pi_{C_{i_1}})$ and $\pi_{C_{i_2}}(\pi^{-1}_{C_{i_1}}(j'+k))=\pi^{-1}_{C_{i_1}}(j'+k)$, the coefficient of $d^{(C_{i_1},\ell_1)}_{j'}$ is $0 + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'} = \gamma^{(C_{i_1})}_{j,j'}$ (here $\beta^{(C_{i_2})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)} \ell_2$ is removed),
%
\item for each $ j' \le r_{C_{i_1}}$ such that $j'+k \in \rng(\pi_{C_{i_1}})$ and $\pi_{C_{i_2}}(\pi^{-1}_{C_{i_1}}(j'+k)) \neq \pi^{-1}_{C_{i_1}}(j'+k)$, the coefficient of $d^{(C_{i_1},\ell_1)}_{j'}$ is $\beta^{(C_{i_2})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)} + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'}$ $=$ $\beta^{(C_{i_2})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)}$ $+$ $\gamma^{(C_{i_1})}_{j,j'}$,
%
\item for each $j' \le r_{C_{i_1}}$ such that $j'+k \not \in \rng(\pi_{C_{i_1}})$, the coefficient of $d^{(C_{i_1},\ell_1)}_{j'}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'} = \gamma^{(C_{i_1})}_{j,j'}$,
%
\item all the other coefficients are those in $\chi^{(C_{i_2})}_{\ell_2}(y_j)$ for the data values introduced in $C^{\ell_2}_{i_2}$.
\end{itemize} 
From the analysis above, we know that when composing $(\chi^{C_{i_1}}_{\ell_1})'$ with $(\chi^{C_{i_2}}_{\ell_2})'$, given a $j': j' \le r_{C_{i_1}}$, the coefficients of all the data values $d^{(C_{i_1},i)}_{j'}$ for $i: 1 \le i < \ell_1$ are the same. Moreover, they will keep the same even we keep composing with $(\chi^{C_{i_3}}_{\ell_3})'$, $(\chi^{C_{i_4}}_{\ell_4})'$, and so on. Therefore, we only need record one copy of these coefficients and there are only a bounded number of coefficients to remember. Then we can construct a finite state automaton $\Aa$ from $\chi_H,\chi_{C_1},\dots,\chi_{C_n}$ to record these coefficients in the states and simulate the evolvement of these coefficients. The final states of $\Aa$ represent the coefficients obtained when reaching the state $q_m$ in $\Ss$. \qed
\end{proof}

\medskip 

\noindent {\bf Step III}. For each final state $\chi$ of $\Aa$ in the claim, check whether the constant coefficient or the coefficient of some data variable in $\chi(O(q_m))$ is nonzero. If the answer is yes, then return $\ltrue$, otherwise, return $\lfalse$.


%From the claim, it follows that the updates of the values of control and data variables along $\schm$, as well as the update of the value of the output expression $O(q_m)$, can be obtained by composing $\chi_H$, $(\chi^{(\Cc_{i_1})}_{\ell_1})'$, $\dots$, and $\chi^{(\Cc_{i_t})}_{\ell_t})'$, which can further be simulated by a $\intnum$-VASS $\Aa$, that is, an integer vector addition system with states (cf. \cite{HH14}). Then the non-zero output reachability of $\Ss$ is reduced to the non-zero reachability of $\Aa$, that is, given an index $i$, decide whether $\Aa$ can reach a vector $\vec{z}$ where $z_i \neq 0$. Finally, we decide the non-zero reachability of $\Aa$. If the answer is ``yes'', then return $\ltrue$, otherwise, return $\lfalse$.

%\begin{proposition}
%The non-zero reachability problem of $\intnum$-VASS is in NP.
%\end{proposition}
%
%\begin{proof}
%The non-zero reachability problem of $\intnum$-VASS can be reduced to the coverability problem of $\intnum$-VASS in polynomial time as follows: Given a $\intnum$-VASS $\Aa$ of dimension $m$ (that is, $m$ is the length of the integer vectors) and an index $i: 1 \le i \le m$, we construct a $\intnum$-VASS $\Bb$ as follows: From each final state of $\Aa$, nondeterministically we choose a subset $Idx \subseteq \{1,\dots,m\}$, and for each $i' \in Idx$, replace $z_{i'}$ by $-z_{i'}$. It is easy to see that $\Aa$ can reach a vector $\vec{z}$ where $z_i \neq 0$ iff $\Bb$ can reach a vector covering $(0,\dots,1,\dots,0)$, that is, the vector whose $i$-th component is $1$ and all the other components are zero.
%
% From the fact that the coverability of $\intnum$-VASS is NP-complete (\cite{HH14}), we know that the non-zero reachability problem of $\intnum$-VASS is in NP. \qed
%\end{proof}
%
%
%Therefore, in this case, the non-zero output reachability problem is reduced to the non-zero reachability problem of $\intnum$-VAS, 



\subsection{Decision procedure for SNTs}

We will illustrate the argument by the following situation, the transition graph comprises a handle $H=q_0\dots q_{m}$,  a collection of cycles $(C_1,\dots,C_n)$ such that $q_m$ is the unique state shared by each pair of them, another handle $H'=q'_0 \dots q'_{m'}$ such that $q'_0=q_m$, and another collection of cycles $(C'_1,\dots,C'_{n'})$ such that $q'_{m'}$ is the unique state shared by each pair of them. Moreover, $O(q'_{m'})$ is defined and $O(q)$ is undefined for all the other states $q$. Suppose $O(q'_{m'}) = a_0 + a_1 x_1 + \dots + a_k x_k + b_1 y_1 + \dots + b_l y_l$.

From Proposition~\ref{prop-sum-path}, we know that 
for the handle $H = q_0 \dots q_m$, a function $\chi_H$ can be constructed to summarize the computation on the handle. Suppose for each $j: 1 \le j \le l$,  $\chi_H(y_j) = \alpha^{(H)}_{j,0} + \gamma^{(H)}_{j,1} d^{(H,0)}_1 + \dots + \gamma^{(H)}_{j,r_H} d^{(H,0)}_{r_H}$, where $d^{(H,0)}_1,\dots, d^{(H,0)}_{r_H}$ represent the $r_H$ data values introduced in the handle. Moreover, there is an injective mapping $\pi_H$ from $\{1,\dots,k\}$ to $\{1,\dots,k+r_H\}$ such that for each $j: 1 \le j \le k$, $\chi_H(x_j) = d^{(H,0)}_{\pi_H(j)-k}$.

Similarly, for the handle $H' = q'_0 \dots q'_{m'}$, a function $\chi_{H'}$ can be constructed to summarize the computation on the handle. Let $d'_1,\dots,d'_k$ and $o'_1,\dots,o'_k$ denote the initial values of the control and data variables respectively. Then for each $j: 1 \le j \le l$,  $\chi_{H'}(y_j) = \alpha^{(H')}_{j,0} + \alpha^{(H')}_{j,1} o'_j + \beta^{(H')}_{j,1} d'_1 + \dots + \beta^{(H')}_{j,k} d'_{k}+ \gamma^{(H')}_{j,1} d^{(H',0)}_1 + \dots + \gamma^{(H')}_{j,r_{H'}} d^{(H',0)}_{r_{H'}}$, where $d^{(H',0)}_1,\dots, d^{(H',0)}_{r_{H'}}$ represent the $r_{H'}$ data values introduced in the handle. Moreover, there is an injective mapping $\pi_{H'}$ from $\{1,\dots,k\}$ to $\{1,\dots,k+r_{H'}\}$ such that for each $j: 1 \le j \le k$, if $\pi_{H'}(j)=j$, then $\chi_{H'}(x_j) = d'_j$, otherwise, $\chi_{H'}(x_j) = d^{(H',0)}_{\pi_{H'}(j)-k}$.

From Proposition~\ref{prop-sum-cycle}, we know that for $\ell \ge 1$, the functions $\chi^{(C_1)}_{\ell}$,$\dots$, $\chi^{(C_n)}_{\ell}$, $\chi^{(C'_1)}_{\ell}$, $\dots$, and $\chi^{(C'_{n'})}_{\ell}$ can be defined to summarize to computation on $C^{\ell}_1$, $\dots$, $C^{\ell}_n$, $(C'_1)^{\ell}$, $\dots$, and $(C'_n)^{\ell}$ respectively. 

Let us check the expression $\chi_{H'}(O(q'_{m'}))$ defined as follows,
\[
\begin{array}{l c l}
\smallskip
\chi_{H'}(O(q'_{m'})) & = & a_0 + a_1 \chi_{H'}(x_1) + \dots a_k \chi_{H'}(x_k) + \\
\smallskip
& & b_1 \chi_{H'}(y_1) + \dots + b_l \chi_{H'}(y_l) \\
\smallskip
&  = &  \left(a_0+\sum \limits_{1 \le j \le l} b_j \alpha^{(H')}_{j,0} \right) + \sum \limits_{j \le k, \pi_{H'}(j)=j} \left(a_j + \sum \limits_{1 \le j' \le l} b_{j'} \beta^{(H')}_{j,j'} \right) d'_j  + \\
%
& & \sum \limits_{j \le k, \pi_{H'}(j) \neq j} \left(\sum \limits_{1 \le j' \le l} (b_{j'} \beta^{(H')}_{j,j'})\right) d'_j + \sum \limits_{1\le j \le l} (b_{j} \alpha^{(H')}_{j,0}) o'_{j} + \\
\smallskip
%
& & \sum \limits_{1 \le j \le r_{H'}, j+k \in \rng(\pi_{H'})} \left(a_{(\pi_{H'})^{-1}(j+k)}+\sum \limits_{1 \le j' \le l} (b_{j'} \gamma^{(H')}_{j,j'})\right) d^{(H',0)}_j +\\ & & \dots  + \sum \limits_{1 \le j \le r_{H'}, j \not \in \rng(\pi_{H'})} \left(\sum \limits_{1 \le j' \le l} (b_{j'} \gamma^{(H')}_{j,j'})\right) d^{(H',0)}_j.
\end{array}
\] 
Let $a'_0,a'_1,\dots,a'_k,b'_1,\dots,b'_l$ denote the constant coefficient, the coefficients of $d'_1,\dots,d'_k$, and the coefficients of $o'_1,\dots,o'_l$ in $\chi_{H'}(O(q'_{m'}))$ respectively. 

Then we can adapt the output function $O$ and set $O(q_m) = a'_0 + a'_1 x_1 + \dots a'_k x_k + b'_1 y_1 + \dots b'_l y_l$.


\smallskip

\noindent {\bf Step I$'$}. By using the output expression $O(q_m)$, we can do the same analysis for the handle $H$ as for generalized lassos.

\smallskip 
\noindent {\bf Step II$'$}. At first, by using $O(q_m)$, we do the following computation, similarly to Step II: For each $i_1: 1 \le i_1 \le n$, if there are a cycle scheme $\schm$  
$HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}
$
or 
$HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t} (C'_{i'_1})^{\ell'_1} (C'_{i'_2})^{\ell'_2} \dots (C'_{i'_{t'}})^{\ell'_{t'}}$,
and $j' \le k$ such that 
\begin{itemize}
\item $i_2,\dots,i_t \le n$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
\item $i'_1,\dots,i'_{t'} \le n'$ are mutually distinct, $\ell'_2 = \dots = \ell'_{t'} = 1$, 
%
\item $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$ (recall that $\mu_{\schm,(i_1,j')}$ is obtained from the coefficient of $d^{(0)}_{\pi_H(j')-k}$ in  $\chi_\schm(O(q_m))$), 
\end{itemize}
then return $\ltrue$. 

Then by using $O(q'_{m'})$, we do the following: For each $i'_1: 1 \le i'_1 \le n'$, if there are a cycle scheme $\schm' =(C'_{i'_1})^{\ell'_1} (C'_{i'_2})^{\ell'_2} \dots (C'_{i'_{t'}})^{\ell'_{t'}}$, and $j' \le k$ such that
\begin{itemize}
\item $i'_2,\dots,i'_t \le n'$ are mutually distinct, $\ell'_2 = \dots = \ell'_t = 1$, 
%
\item $\pi_{C'_{i_1}}(j')=j'$, and $\mu_{\schm',(i'_1,j')} \neq 0$ (here $\mu_{\schm',(i_1,j')}$ is obtained from the coefficient of $d''_{j'}$ in  $\chi_{\schm'}(O(q'_{m'}))$, where $d''_1,\dots,d''_k$ denote the initial data values of $x_1,\dots,x_k$ respectively),
\end{itemize}
then return $\ltrue$. 

Similarly, we can apply an analysis for the constant coefficient to $\chi_\schm(O(q_m))$. 

If the decision procedure has not return yet, then go to Step III$'$. \qed

\smallskip

Similarly to the generalized lassos, we can construct a finite state automaton $\Aa'$ from $\chi_H,\chi_{C_1},\dots,\chi_{C_n},\chi_{H'}, \chi_{C'_1},\dots,\chi_{C'_{n'}}$ to record the coefficients in the states and simulate the evolvement of these coefficients. The final states of $\Aa$ represent the coefficients obtained when reaching the state $q'_{m'}$ in $\Ss$. 

\smallskip 

\noindent {\bf Step III$'$}. For each final state $\chi'$ of $\Aa'$ in the claim, check whether the constant coefficient or the coefficient of some data variable in $\chi'(O(q'_{m'}))$ is nonzero. If the answer is yes, then return $\ltrue$, otherwise, return $\lfalse$.





\section{Case Studies}

	\begin{lstlisting}[mathescape=true]
	int MAD() {
	...
	// repeat the body  
	// of (b) to compute
	// sum and cnt
	
	init();
	avg:= sum/cnt;
	mad:=0;
	while(cur()$\neq$end()){
	if(cur()<avg){
	mad=mad+(avg-cur());
	}else{
	mad=mad+(cur()-avg);
	}
	next();
	}
	return mad/cnt;
	}
	\end{lstlisting}
	
\section{Discussions}

From the analysis of the commutativity of reducers in \cite{XZZ+14}, the commutativity of a reducer in a sequential composition oa map-reduce jobs may depend on some implicit data properties guaranteed by the preceding map-reduce jobs. Therefore, to analyze the commutativity of a reducer in a sequential composition of map-reduce jobs, we may need model both mappers and reducers and do a backward analysis.

\bibliographystyle{abbrv}
\bibliography{data}


\newpage

\begin{appendix}

\section{Proofs in Section~\ref{sec-def-snt}}

\noindent {\bf Proposition~\ref{prop-snt-cmm-to-eqv}}. 
\emph{The commutativity problem of SNTs is reduced to the equivalence problem of SNTs in exponential time}.

\begin{proof}
Suppose that $\Ss=(Q, X, Y, \delta, q_0, O)$ is a SNT. Without loss of generality, we assume that the output of $\Ss$ is defined only for data words of length at least two. We will construct two SNTs $\Ss_1$ and $\Ss_2$ so that $\Ss$ is commutative iff $\Ss$ is equivalent to both $\Ss_1$ and $\Ss_2$.
\begin{itemize}
\item The intuition of $\Ss_1$ is that over a data word $w=d_1 d_2 d_3 \dots d_n$ with $n\ge 2$, $\Ss_1$ simulates the run of $\Ss$ over $d_2 d_1 d_3 \dots d_n$, that is, the data word obtained from $w$ by swapping the first two data values.
%
\item The intuition of $\Ss_2$ is that over a data word $w=d_1 d_2 d_3 \dots d_n$ with $n\ge 2$, $\Ss_1$ simulates the run of $\Ss$ over $d_2 d_3 \dots d_n d_1$, that is, the data word obtained from $w$ by moving first data value to the end. 
\end{itemize}
The correctness of this reduction follows from Proposition 1 in \cite{CHSW15}.

\smallskip

\noindent {\it The construction of $\Ss_1$}.

Intuitively, over a data word $w=d_1d_2 d_3 \dots d_n$, we introduce an additional control variable $x'$ to store $d_1$, then simulates the run of $\Ss$ over $d_2 d_1 d_3 \dots d_n$ as follows: When reading $d_2$ in $w$, the data variables are updated properly by letting $x'$ to represent $d_1$ and $\cur$ to represent $d_2$.

Without loss of generality, we assume that for each pair of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2$ in $\Ss$, the following constraints are satisfied,
\begin{itemize}
\item $g_1$ does not contain any variable from $X$,
%
\item for each variable $x \in X$ such that $x$ occurs in $g_2$, it holds that $x \in \dom(\eta_1)$,
%
\item after these two transitions, the values of all the variables from $\dom(\eta_1) \cup \dom(\eta_2)$ are defined, more specifically, for each $y \in Y \cap \dom(\eta_2)$ and each $z \in \vars(\eta_2(y))$, it holds that $z \in \dom(\eta_1)$.
\end{itemize}

Let $q'_{0},q'_{1} \not \in Q$ and $x' \not \in X$. Then $\Ss_1 = (Q \cup \{q'_{0},q'_1\}, X \cup \{x'\}, Y, \delta_1, q'_{0}, O_1)$ such that 
\begin{itemize}
\item $O_1(q'_0)$ and $O_1(q'_1)$ are undefined, and for each $q \in Q$, $O_1(q)=O(q)$,
%
\item $\delta_1$ is constructed from $\delta$ as follows,
\begin{itemize}
\item each element of $\delta$ is an element of $\delta_1$,
%
\item for each pair of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2$ in $\Ss$, we add the transitions $(q_0, \ltrue, \eta'_1, q'_1)$ and $(q'_1, g', \eta'_2, q_2)$ into $\delta_1$, where $\eta'_1,g',\eta'_2$ are defined in the following. Suppose $X \cap \dom(\eta_1)=\{x_1,\dots,x_k\}$, for each $y \in Y \cap \dom(\eta_1)$, $\eta_1(y)=a_{1,y} + b_{1,y}\cur$, and for each $y \in Y \cap \dom(\eta_2)$, 
\[\eta_2(y)=a_{2,y} + b_{2,y} \cur + c_{y,0} y + c_{y,1} x_1 + \dots + c_{y,k} x_k,\] 
or 
\[
\eta_2(y)=a_{2,y} + b_{2,y} \cur + c_{y,1} x_1 + \dots + c_{y,k} x_k.
\]
Then $\eta'_1, g', \eta'_2$ are defined as follows.
\begin{itemize}
\item $\eta'_1(x')=\cur$, for each $x \in X \cap \dom(\eta_2)$, $\eta'_1(x)=\cur$, and for all the other variables $z$ from $X \cup Y$, $\eta'_1(z)$ is undefined.
%
\item $g' = g_1 \wedge g'_2$, where $g'_2$ is obtained from $g_2$ by replacing $\cur$ with $x'$, and each $x \in X$ with $\cur$.
%
\item For each $x \in X$, if $x \in \dom(\eta_2)$, then $\eta'_2(x)$ is undefined, otherwise, if $x \in \dom(\eta_1)$, then $\eta'_2(x)=\cur$, otherwise, $\eta'_2(x)$ is undefined.
%
\item For each $y \in Y$, if $y \in \dom(\eta_2)$, then 
\[
\begin{array}{l c l}
\eta'_2(y) & = & a_{2,y} + b_{2,y} x' + c_{y,0} (a_{1,y} + b_{1,y}\cur) + c_{y,1} \cur + \dots + c_{y,k} \cur \\
& = & (a_{2,y} + c_{y,0} a_{1,y}) + b_{2,y} x' + (c_{y,0} b_{1,y}  + c_{y,1} + \dots + c_{y,k} )\cur,
\end{array}
\]
or 
\[
\begin{array}{l c l}
\eta'_2(y) & = & a_{2,y} + b_{2,y} x' + c_{y,1} \cur + \dots + c_{y,k} \cur \\
& = & a_{2,y} + b_{2,y} x' + (c_{y,1} + \dots + c_{y,k} )\cur.
\end{array}
\]
%
Otherwise, if $y \in \dom(\eta_1)$, then $\eta'_2(y)= a_{1,y} + b_{1,y} \cur$. Otherwise, $\eta'_2(y)$ is undefined.
\end{itemize}
\end{itemize}
\end{itemize}
It is easy to see that the size of $\Ss_1$ is polynomial with respect to the size of $\Ss$.

\smallskip

\noindent {\it The construction of $\Ss_2$}.

Intuitively, over a data word $w=d_1\dots d_n$, we introduce an additional control variable $x'$ to store $d_1$, then simulates the run of $\Ss$ over $d_2\dots d_n d_1$: When reaching the end of $w$, $\Ss_2$ outputs immediately by using $x'$ to represent $d_1$ and simulating the last transition of $\Ss$ over $d_2 \dots d_n d_1$. In order to simulate \emph{deterministically} the last transition of $\Ss$ over $d_2 \dots d_n d_1$ when reading the end of $w$ (since SNTs are required to be deterministic), we need record in the states of $\Ss_2$ the relationship between $d_1$ and all the values stored in the control variables. This implies an exponential blow-up of the size of $\Ss_2$ with respect to $\Ss$.

Let $c_{\max}$ and $c_{\min}$ denote the maximum resp. minimum constant occurring the guards of the transitions of $\Ss$.

Suppose $q'_{0} \not \in Q$ and $x' \not \in X$. Then $\Ss_2 = (Q', Y, \delta_2, q'_{0}, O_2)$, where $O',\delta_2,O_2$ are defined as follows. 
\begin{itemize}
\item $Q' = \{q_0\} \cup \left(\left([c_{\min}, c_{\max}] \cup \{-\infty,+\infty\}\right) \times X^{\{=, <, >,\bot\}} \right)$, where $[c_{\min},c_{\max}]= \{c \in \intnum \mid c_{\min} \le c \le c_{\max} \}$.
%
\item $\delta_2$ is defined as follows, 
\begin{itemize}
\item for each $c \in [c_{\min}, c_{\max}] \cup \{-\infty,+\infty\}$, $\delta_2$ contains $(q'_0,\ltrue,\eta, (q_0,(c, o_0)))$, where $\dom(\eta)=\{x'\}$, $\eta(x')=\cur$, and $o_0(x) = \bot$ for each $x \in X$,
%
\item for each $(q,g,\eta,q') \in \delta$ and $(q,(c,o)) \in Q'$ such that the guard $g \wedge \bigwedge \limits_{x \in X, o(x) \neq \bot} x'\ o(x)\ x$ is satisfiable, then $\delta_2$ contains the following three transitions, 
$((q,(c,o)), g \wedge \cur = x', \eta, (q',(c,o'_1)))$, $((q,(c,o)), g \wedge \cur< x', \eta, (q',(c,o'_2)))$, and $((q,(c,o)), g \wedge \cur > x', \eta, (q',(c,o'_3)))$, 
where 
for each $x \in X$, if $x \in \dom(\eta)$, then $o'_1(x) = \ =$, $o'_2(x)=\ >$, and $o'_3(x) =\ <$, otherwise, $o'_1(x) = o'_2(x) = o'_3(x) = o(x)$.
\end{itemize}
%
\item $O_2$ is defined as follows: For each $(q,(c,o)) \in Q'$  such that there is $(q,g,\eta,q') \in \delta$ satisfying that $\left(\bigwedge \limits_{x \in X, o(x) \neq \bot} \cur\ o(x)\ x \right) \models g$, and $O(q')$ is defined, suppose 
\[O(q')=a+b_1 x_1 + \dots + b_k x_k + c_1 y_1 + \dots + c_l y_l,\]
where $x_1,\dots,x_k$ (resp. $y_1,\dots,y_l$) are pairwise distinct variables from $X$ (resp. $Y$),
then let
\[O_2((q,(c,o)))=a+b_1 \eta'(x_1) + \dots + b_k \eta'(x_k) + c_1 \eta'(y_1) + \dots + c_l \eta'(y_l),\]
where for each $z \in \dom(\eta)$, $\eta'(z)=\eta(z)$, and for all the other variables $z' \in X \cup Y$, $\eta'(z')=z'$.  \\
Note that $O_2$ is well-defined since for each $(q,(c,o)) \in Q'$, there is a unique $(q,g,\eta,q') \in \delta$ satisfying the aforementioned constraint.
\end{itemize}
%
Note that $\Ss_1$ and $\Ss_2$ constructed above preserve the generalized flatness of $\Ss$.
\qed
\end{proof}


\noindent {\bf Proposition \ref{prop-snt-eqv-to-nzero}}.
\emph{From SNT $\Ss_1$ and $\Ss_2$, a SNT $\Ss_3$ can be constructed in polynomial time such that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss_3$ over $w$ is nonzero.}

\begin{proof}
Let $\Ss_1 = (Q_1,X_1,Y_1,\delta_1,q_{1,0}, O_1)$ and  $\Ss_2 = (Q_2,X_2,Y_2,\delta_2,q_{2,0}, O_2)$ be two SNTs. Without loss of generality, we assume that $Q_1 \cap Q_2 = \emptyset$, $X_1 \cap X_2 = \emptyset$, and $Y_1 \cap Y_2 = \emptyset$. 

Intuitively, we construct $\Ss$ as the product of $\Ss_1$ and $\Ss_2$. Specifically, $\Ss=(Q_1 \times Q_2, X_1 \cup X_2, Y_1 \cup Y_2, \delta, (q_{1,0},q_{2,0}), O)$, where
\begin{itemize}
\item $\delta$ comprises $((q_1,q_2), g_1 \wedge g_2, \eta_1 \cup \eta_2, (q'_1,q'_2))$ such that $(q_1,g_1,\eta_1,q'_1) \in \delta_1$ and $(q_2,g_2,\eta_2,q'_2) \in \delta_2$,
%
\item for each $(q_1,q_2) \in Q_1 \times Q_2$, 
\begin{itemize}
\item if $O_1(q_1)$ is defined and $O_2(q_2)$ is undefined or vice versa, then $O((q_1,q_2))=1$, 
%
\item otherwise, if both $O_1(q_1)$ and $O_2(q_2)$ are defined, then $O((q_1,q_2))=O_1(q_1) - O_2(q_2)$, 
%
\item otherwise (both $O_1(q_1)$ and $O_2(q_2)$ are undefined), $O((q_1,q_2))$ is undefined. 
\end{itemize}
\end{itemize}
From the aforementioned construction and the assumption that $\Ss$ is well-defined, it is easy to see that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss$ over $w$ is non-zero.\qed
\end{proof}

\section{Translate a Reducer Program to a SNT}
\begin{algorithm}[H]
	%  \SetAlgoLine
	\KwData{A reducer program $p$}
	$Q=\{q_0\}, \delta=\emptyset, O=\emptyset$, $\mathsf{toState}(p) =q_0$, $\mathsf{toVisit}=\{(\mathsf{toState}(p),p,\ltrue,\emptyset)\}$\;
	\While{$\mathsf{toVisit}\neq \emptyset$}{
		remove $(q,p,g,\eta)$ from $\mathsf{toVisit}$\;
		\Switch{$p$}{
			\lCase{$y := e;p'$,$y \addeq e;p'$,$x'=x;p'$: }{add $(q,p',g,\eta[e/y])$, $(q,p',g,\eta[(y+e)/y])$, $(q,p',g,\eta[x'/x])$ to $\mathsf{toVisit}$, respectively}
			\lCase{$\ite{g'}{s_1}{s_2};p'$: }{add both $(q,s_1;p',g\wedge g',\eta)$ and $(q,s_2;p',g\wedge \neg g',\eta)$ to $\mathsf{toVisit}$}
			\lCase{$\loopL{s;}\mbox{ret }r$: }{add both $(q,s;\loopL{s;}\mbox{ret }r,g,\eta)$ and $(q,\mbox{ret }r, g,\eta)$ to $\mathsf{toVisit}$}
			\lCase{$\next;p'$: }{\label{alg:next}
				\uIf{$\mathsf{toState}(p') \not\in Q$}{add $(\mathsf{toState}(p'),p',\ltrue,\emptyset)$ to $\mathsf{toVisit}$ and add $\mathsf{toState}(p')$ to $Q$}
				add $(q, \mathsf{toState}(p'),g,\eta)$ to $\delta$
			}
			\lCase{$\mbox{ret }r: $}{\label{alg:output}
				add a fresh state $q_r$ to $Q$, 
				add $(q, q_r,g,\eta)$ to $\delta$, and $O:=O[r/q_r]$}
		}
	}
	\Return $(Q,X,Y,\delta, \mathsf{toState}(p),O)$\;
	
	\caption{Translate a Reducer Program to a SNT}
	\label{fig:reducer2SNT}
\end{algorithm}
We use a tuple $(q,p,g,\eta)$ to store intermediate results of the translation, where $q$ is the source SNT state, $p$ is a reducer program, $g$ is a guard, and $\eta$ is an assignment.
The algorithm begins with the tuple $(p,p,\ltrue,\emptyset)$. The algorithm add a transition to SNT only when a $\next$ statement is encountered (line~\ref{alg:next}). When a $\mbox{ret }r$ statement is encountered, the algorithm adds a fresh state $q_r$ to the SNT and extends the output function to $O[r/q_r]$ (line~\ref{alg:output}).





\section{Proofs in Section~\ref{sec-dec-snt}}


\noindent {\bf Proposition~\ref{prop-snt-norm}}.
{\it From each SNT, an equivalent normalized SNT can be constructed in exponential time.} 

\smallskip

\begin{proof}
To be done.
\qed
\end{proof}


\noindent {\bf Proposition~\ref{prop-sum-path}}.
{\it The values of the control and data variables after traversing the path $P$ are specified by a function $\chi$ satisfying the following conditions.
\begin{itemize}
\item There is an injective mapping $\pi: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi(j) \le k$, then $\pi(j)=j$ and $\chi(x_j)=d^{(0)}_{j}$, otherwise, $\chi(x_j)=d^{(1)}_{\pi(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi(y_j) = \alpha_{j,0} + \alpha_{j,1} o_j + \beta_{j,1} d^{(0)}_1 + \dots + \beta_{j,k} d^{(0)}_k + \gamma_{j,1} d^{(1)}_1 +\dots + \gamma_{j,r} d^{(1)}_{r}$ for some constants $\alpha_{j,0},\alpha_{j,1}, \beta_{j,1},\dots,\beta_{j,k}, \gamma_{j,1},\dots,\gamma_{j,r}$ such that $\alpha_{j,1} \in \{0,+1,-1\}$ (as a result of the ``independently evolving and copyless'' constraint).
\end{itemize}
}

\begin{proof}
We show by an induction that for each $i: 1 \le i \le n$ and each variable $x_j \in X$ (resp. $y_j \in Y$), an expression $e_{i,x_j}$ (resp. $e_{i,y_j}$) can be constructed to describe the value of $x_j$(resp. $y_j$) after going through the first $i$ transitions of the path. 
%
\begin{itemize}
\item Let $\theta_0$ be an assignment such that for each $x_j \in X$ (resp. $y_j \in Y$), $\theta_0(x_j)=d^{(0)}_j$ (resp. $\theta_0(y_j)=o_j$), moreover, $\theta_0(\cur)=d^{(1)}_1$.
%
%\item For each $x_j \in X$, if $x_j \in \dom(\eta_1)$, then $e_{1,x_j}=d^{(1)}_1$, otherwise, $e_{1,x_j}=d^{(0)}_j$. For each $y_j \in Y$, if $y_j \in \dom(\eta_1)$, then $e_{1,y_j} = \theta_0(\eta_{1}(y_j))$,
%otherwise, $e_{1,y_j}=o_j$. 
%
\item Let $i: 1 \le i \le n$. 
\begin{itemize}
\item For each $x_j \in X$, if $x_j \in \dom(\eta_i)$, then $e_{i,x_j}=\theta_{i-1}(\cur)$, otherwise, $e_{i,x_j}=\theta_{i-1}(x_j)$.
%
\item For each $y_j \in Y$, if $y_j \in \dom(\eta_i)$, then $e_{i,y_j} = \theta_{i-1}(\eta_i(y_j))$, otherwise, $e_{i,y_j}=\theta_{i-1}(y_j)$.
%
\item For each $x_{j} \in X$ (resp. $y_j \in Y$), $\theta_i(x_{j})=e_{i,x_{j}}$ (resp. $\theta_i(y_{j})=e_{i, y_{j}}$). If $i < n$, then $\theta_i(\cur)=d^{(1)}_{s}$, where $1\le s \le r$ and $k+i + 1 \in I_s$, otherwise, $\theta_i(\cur)=\bot$.
\end{itemize}
\end{itemize}
Then the function $\chi$ can be defined as the restriction of $\theta_n$ to $X \cup Y$.
\qed
\end{proof}


\noindent {\bf Proposition~\ref{prop-sum-cycle}}.
{\it Suppose $P=C^{\ell}$ such that $\ell \ge 2$. Then the function $\chi^{(C)}_{\ell}$ to summarize the computation of $\Ss$ on $P$ is defined as follows,
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0}+ \dots +(\alpha^{(C)}_{j,1})^{\ell-1} \alpha^{(C)}_{j,0}) + (\alpha^{(C)}_{j,1})^\ell o_j + \\
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1}\beta^{(C)}_{j,j'} + \dots +(\alpha^{(C)}_{j,1})^{\ell-1}  \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \\
%
& & \sum \limits_{j'\le k, \pi_C(j') \neq j'} ((\alpha^{(C)}_{j,1})^{\ell-1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( (\alpha^{(C)}_{j,1})^{\ell-2} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +(\alpha^{(C)}_{j,1})^{\ell-1}\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} ((\alpha^{(C)}_{j,1})^{\ell-1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1}\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C},
\end{array} 
\]
where $d^{(C,2)}_{1},\dots, d^{(C,2)}_{r_C},\dots, d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$
 are the data values introduced when traversing $C$ for the second time, $\dots$, and for $\ell$ times.
}
%
\begin{proof}
Let $d^{(C,2)}_{1},\dots,d^{(C,2)}_{r_C}$ be the data values introduced when traversing the cycle for the second time. Then from Corollary~\ref{cor-comp-two-paths}, we know that $\chi^{(C)}_2 = \chi_{C} \circ \chi_C$ is defined as follows: For each $y_j \in Y$,
\[
\begin{array}{l c l}
\smallskip
\chi^{(C)}_2(y_j) & =  & (\alpha^{(C)}_{j,0}+\alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0})+ (\alpha^{(C)}_{j,1})^2 o_j + \\
%
\smallskip
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \sum \limits_{j' \le k, \pi_C(j') \neq j'} (\alpha^{(C)}_{j,1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'}  \\
%
& & + \sum \limits_{j' \le r_C, j' + k \in \rng(\pi_C)} (\beta^{(C)}_{j,\pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} +\\
%
& & \sum \limits_{j' \le r_C, j' + k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + 
 \gamma^{(C)}_{j,1} d^{(C,2)}_1 +\dots + \gamma^{(C)}_{j,r_C} d^{(C,2)}_{r_C}.
\end{array}
\] 
For $\ell > 3$, let $d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$ be the data values introduced when traversing the cycle for the $\ell$-th time. Then from Corollary~\ref{cor-comp-two-paths}, the fact $\chi^{(C)}_\ell = \chi_C \circ \chi^{(C)}_{\ell-1}$, and the induction hypothesis, we can show that $\chi^{(C)}_\ell$ is of the desired form.
\qed
\end{proof}





\subsection{Comparisons with constants in guards}

We now consider the situation that the guards contain the comparisons with constants, that is, the atomic formulae of the form $cur\ o\ c$, where $c$ is an integer constant. 

We illustrate the argument for generalized lassos and adapt the decision procedure Step I-III to Step I$''$-III$''$ below.

Let $q_0 \dots q_m C_1 \dots C_n$ be a generalized lasso and $O(q_m)=a_0 + a_1 x_1 + \dots + a_k x_k + b_1 y_1 + \dots + b_l y_l$.

\smallskip

\noindent {\bf Step I$''$}. Let
\[
\begin{array}{l c l }
\chi_H(O(q_m)) & = & a_0 + a_1 \chi_H(x_1) + \dots + a_k \chi_H(x_k) + b_1 \chi_H(y_1) + \dots b_l \chi_H(y_l) \\
& = & (a_0+b_1 \alpha^{(H)}_{1,0} + \dots + b_l \alpha^{(H)}_{l,0}) + \\
& & \sum \limits_{j \le r_H, j+k \in \rng(\pi_H)} (a_{\pi_H^{-1}(j+k)}+ b_1 \gamma^{(H)}_{j,1}+\dots + b_l \gamma^{(H)}_{j,l}) d^{(0)}_j +
\\
& & \sum \limits_{j \le r_H, j +k \not \in \rng(\pi_H)}  (b_1 \gamma^{(H)}_{j,1}+\dots + b_l \gamma^{(H)}_{j,l}) d^{(0)}_j .
\end{array}
\]
From the guards and assignments of the transitions in $H$, we know that some of $d^{(0)}_1,\dots,d^{(0)}_{r_H}$ are integer constants between $c_{\min}$ and $c_{\max}$. Let $J_H \subseteq \{1,\dots, r_H\}$ denote the indices $j: 1 \le j \le r_H$ such that $d^{(0)}_j = c^{(H)}_j$ for some $c_{\min}\le c^{(H)}_j \le c_{\max}$. Since $\Ss$ is assumed to be normalized, we know that for $j \not \in J_H$,  $d^{(0)}_j < c_{\min}$ or $d^{(0)}_j > c_{\max}$.

For each $j \not \in J_H$, decide whether the coefficient of $d^{(0)}_j$ in $\chi_H(O(q_m))$ is nonzero. If the answer is yes, then return $\ltrue$. 

If the algorithm has not return yet, we substitute the data variables $d^{(0)}_j$ for $j \in J_H$ with the integer constants. Then $\chi_H(O(q_m))$ becomes an integer constant $c_H$. If $c_H \neq 0$, then return $\ltrue$.  Otherwise, go to Step II$''$. \qed

\medskip

For each $i_1: 1 \le i_1 \le n$, let $J_{C_{i_1}}$ denote the indices $j': 1 \le j' \le l$ such that there is $c^{C_{i_1}}_{j'}$ satisfying that $c_{\min} \le c^{C_{i_1}}_{j'} \le c_{\max}$, and for each $i: 1 \le i \le \ell_1$, $d^{(C_{i_1},i)}_{j'}=c^{C_{i_1}}_{j'}$ in $\chi^{(C_{i_1})}_{\ell_1}$. 

For a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$, let $c_{\schm,i_1}$ denote the sum of all the following expressions (intuitively, $c_{\schm,i_1}$ is the constant coefficient of $\chi_\schm(O(q_m))$ involving the terms $ c\ \ell_1$ for some integer constant $c$, when taking into consideration the fact that some introduced data values are in fact integer constants between $c_{\min}$ and $c_{\max}$),
\[
\sum \limits_{1 \le j \le l} 
%\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) 
%\\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \alpha^{(C_{i_1})}_{j,0},
%\end{array}
\]
the expressions 
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) c^{(H)}_{\pi_H(j')-k}
\]
such that $j' \le k$, $\pi_H(j')-k \in J_H$ (Recall that $d^{(0)}_{\pi_H(j')-k}=c^{(H)}_{\pi_H(j')-k}$), \\
the expressions
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left((\alpha^{(C_{i_1})}_{j,1})^{\ell_1-i-1} \beta^{(C_{i_1})}_{j,\pi^{-1}_{C_{i_1}}(j'+k)} + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-i} \gamma^{(C_{i_1})}_{j,j'}\right)
\end{array}
\right) c^{(C_{i_1})}_{j'},
\]
such that $1 \le i < \ell_1$, $j' \in J_{C_{i_1}}$, and $j'+k \in \rng(\pi_{C_{i_1}})$,\\
the expressions
\[
\left(\sum \limits_{1 \le j \le l} 
%\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right)  \left( (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-i} \gamma^{(C_{i_1})}_{j,j'}\right)
%\end{array}
\right) c^{(C_{i_1})}_{j'},
\]
such that $i: 1 \le i \le \ell_1$, $j' \in J_{C_{i_1}}$, and $j'+k \not \in \rng(\pi_{C_{i_1}})$.

Then $c_{\schm,i_1}$ can be rewritten as $\mu_{\schm, (i_1,0)} \ell_1 + \nu_{\schm, (i_1,0)}$ for constants $\mu_{\schm, (i_1,0)},\nu_{\schm, (i_1,0)}$.

\medskip

\noindent {\bf Step II$''$}. For each $i_1: 1 \le i_1 \le n$, if there are a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$  and $j' \le k$ such that 
\begin{itemize}
\item $i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
\item $\pi_H(j')-k \not \in J_H$, $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$, 
\end{itemize}
then return $\ltrue$.

If there is a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that 
$i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
and $\mu_{\schm,(i_1,0)} \neq 0$, 
%
then return $\ltrue$. 

If the decision procedure has not return yet, then go to Step III$''$. \qed

\medskip

If after Step II, the algorithm has not return yet, then after removing the terms involving $c\ \ell_1,\dots, c\ \ell_t$, a finite state automaton $\Aa$ can be constructed to simulate the evolvement of the coefficients of the non-constant data variables, and the sum of the constant coefficients and all the terms involving the data variables which are integer constants. 

\medskip



\noindent {\bf Step III$''$}. For each final state $\chi$ of $\Aa$, do the following.
\begin{itemize}
\item Check whether the coefficient of some non-constant data variable in $\chi(O(q_m))$ is nonzero, if the answer is yes, then return $\ltrue$.
%
\item Otherwise, check whether the number obtained from $\chi(O(q_m))$ by replacing the remaining data variables with the corresponding integer constants, is nonzero. If the answer is yes, then return $\ltrue$. 
\end{itemize}
Finally, return $\lfalse$ and the algorithm terminates.




\end{appendix}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



