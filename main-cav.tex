\documentclass[runningheads,a4paper]{llncs}

\usepackage{latexsym}
\usepackage{setspace}
\usepackage{cancel}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{appendix}
\usepackage{amssymb}
%\usepackage{dsfont}
\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{cancel}
%\usepackage{verbatim}
%\usepackage{chngpage}
%\usepackage{fullpage}

\usepackage{color}

\usepackage{mathrsfs}

%\newtheorem{definition}{Definition}
%\newtheorem{theorem}{Theorem}
%\newtheorem{proposition}[theorem]{Proposition}
%\newtheorem{corollary}[theorem]{Corollary}
%\newtheorem{example}{Example}
%\newtheorem{question}{Open Question}
%\newtheorem{lemma}[theorem]{Lemma}
%\newtheorem{Algo}{Algorithm}
%\newtheorem{remark}[theorem]{Remark}

\def\arr#1{\stackrel{#1}{\longrightarrow}}

\def\Aa{{\mathcal{A} }}

\def\Bb{{\mathscr{B} }}

\def\Cc{{\mathcal{C} }}

\def\Dd{{\mathbb{D} }}

\def\Ee{{\mathcal{E} }}

\def\Ff{{\mathcal{F} }}

\def\Zz{{\mathcal{Z} }}

\def\Nn{{\mathbb{N} }}

\def\Ss{{\mathcal{S} }}

\def\schm{{\mathfrak{s} }}

\def\Tt{{\mathcal{T} }}

\def\Ii{{\mathbb{Z} }}

\def\Jj{{\mathcal{J}}}

\def\Vv{{\mathcal{V}}}

\def\Rr{{\mathcal{R} }}

\def\Ll{{\mathcal{L}}}


\def\treeset{{\mathscr{T}}}

\def\contextset{{\mathcal{C}}}

\def\theory{{\mathcal{L}}}

\def\termset{{\mathcal{T}}}

\def\formulaset{{\mathcal{F}}}

\newcommand\univ{\mathsf{Univ}}

\newcommand\op{\mathfrak{o}}

\newcommand\dv{\mathtt{x}}

\newcommand\ydv{\mathtt{y}}

\newcommand\cv{\mathtt{z}}

\newcommand\thla{\mathcal{LIA}}

\newcommand\thdif{\mathcal{DIF}}

\newcommand\thord{\mathcal{ORD}}

\newcommand\thset{\mathcal{SET}}

\newcommand\thmset{\mathcal{MUS}}

\newcommand\natnum{{\mathbb{N} }}

\newcommand\intnum{{\mathbb{Z} }}

\newcommand\cur{\mathsf{cur}}

\newcommand\vars{\mathsf{vars}}

\newcommand\intvars{\mathcal{X}}

\newcommand\dom{\mathsf{dom}}

\newcommand\rng{\mathsf{rng}}

\newcommand\ltrue{\mathsf{true}}

\newcommand\lfalse{\mathsf{false}}

\newcommand\avg{\mathrm{avg}}

\newcommand\maxv{\mathsf{max}}

\newcommand\sumv{\mathsf{sum}}

\newcommand\cntv{\mathsf{cnt}}

\newcommand\defval{\mathsf{DEF}}
\newcommand{\sub}[2]{#1|_{#2}}


\newcommand{\hide}[1]{}
\newcommand{\yfc}[1]{\color{blue} {YF: #1 :FY} \color{black}}
\newcommand{\zhilin}[1]{\color{cyan} {ZL: #1 :LZ} \color{black}}
\newcommand{\lei}[1]{\color{green} {LE: #1 :EL} \color{black}}
\newcommand{\SDSIT}{SDSIT}
\newcommand{\Name}{Streaming data string to integer transducer}
\newcommand{\name}{streaming data string to integer transducer}
%\def\Ss{{$\mathcal{A}$\ }}

\title{The~Commutativity~Problem~of~the~Map-Reduce Framework: A Transducer-based Approach}
\titlerunning{Commutativity of MapReduce: A Transducer-based Approach}
\author{}
\institute{}

%\author{Yu-Fang Chen, Lei Song, Zhilin Wu}

\begin{document}

\maketitle

\begin{abstract}

MapReduce is a popular programming model for data parallel computation. 
In MapReduce, the \emph{reducer} produces an output from a list of inputs. Due the scheduling policy and the settings of machines, the input may arrive the reducers with different orders. The \emph{commutative problem} of reducers asks if the output of a reducer independent of the order of its inputs. The problem is in general undecidable due to Rice's theorem and thus is seemingly uninteresting. However, the MapReduce model is usually used for data analytics and thus requires very simple data and control flow. 
By exploiting the simplicity of the required program flows, we propose a simple programming language for reducers where the commutative problem can be decide by a reduction to the equivalence problem of \emph{streaming numerical transducer}. 
We show that the language is expressive enough for common data analytics operations.
\end{abstract}

\section{Introduction}
%What is Map-Reduce
Map-Reduce is a  popular framework for data parallel computation. It has been adopt in various widely used cloud computing frameworks such as Hadoop~\cite{Hadoop} and Spark~\cite{Spark}. In a typical Map-Reduce program, a \emph{mapper} reads from data sources and outputs a list of key-value pairs. The load balance mechanism of the Map-Reduce framework processes the key-value pairs and sends the pairs with the same key to the same \emph{reducer}, in the form of a key and a list of values. The reducer then iterates through the input list and output a key-value pair.

To be more concrete, taking the ``word-counting'' MapReduce program as an example. It counts the occurrences of each word in a set of documents. The mappers reads the documents and output for each document a list in the form of $(word_1, count_1), (word_2, count_2), \ldots, (word_n, count_n)$, where $count_k$ is the number of occurrences of $word_k$ in the document being processed. These lists will be reorganized into the form of $(word_1, list_1), (word_2,list_2), \ldots, (word_n,list_n)$ and sent to the reducers, where $list_k$ is a list of integers recording the number of occurrences of $word_k$ in the set of documents. Note that the \emph{order} of the integers in the lists can differ in different executions due to network latency, load balancing, etc.
This results in the \emph{commutativity problem}.

%The communitativity problem
We say that a reducer is \emph{commutativity} if its output is independent of the order of its inputs. The commutativity problem asks if a reducer is commutativity. A study from Microsoft~\cite{XZZ+14} reports that XX\% of the reducers submit to their MapReduce platform are non-commutative. Among them, YY\% are confirmed as correctness bug by the programmers who wrote them. So we know that non-commutativity is a good indicator for errors in the programs. 
Moreover, having the commutativity property makes program testing easier. It is hard to reproduce a bug if the reducer under test is non-commutative. 

%The reason for studying syntatical restrictions 
The reducer commutative problem in general is undecidable by Rice's theorem. However, in practice, the reducers are seldom Turing machines. They are usually used for data analytics and have very simple control structures. Many of them just iterate through the input list and compute the output with very simple operations.
We want to study if the commutative problem of real-world reducers are decidable.

A simple programming language of reducers over integers has been considered in~\cite{CHSW15}, where the only loop structure allowed is an iteration over the input list and it is not allowed to reset the iterator to the list head. They show that the commutative problem of programs written by such a simple language is undecidable by a reduction from the satisfiability problem of Diophantine equations. Under scrutiny, we found that the language is still too expressive for typical data analytics programs. For example, it allows multiplications of two different variables, which is a key element in the undecidability proof. 
\hide{
\begin{figure}
	\centering
	\begin{tabular}{rcl}
		$c \in \mathbb{Z}$&&\\	
		$v \in Var$&$\equiv$&$x \mid y \mid z \mid cur()\mid \ldots$\\
		$g \in Guard$&$\equiv$&$cur() > v \mid cur()= v \mid v>c \mid v=c \mid \neg g \mid g\wedge g$\\
		$e \in Expressions$&$\equiv$&$c\mid v \mid e+e \mid e\times e \mid e - e$\\
		$ s \in Statements$&$\equiv$&$v := e\mid s;s\mid \mbox{if(} g \mbox{)then\{} s;\mbox{\}else\{}s;\mbox{\}}\mid \mbox{return }e\mid $\\
		&&$\mbox{while(}cur()\neq end() \mbox{)\{} s;\mbox{\}}\mid next()$		
	\end{tabular}
	\label{fig:language}
	\caption{A Simple Programming Language for Reducers}
\end{figure}
}

By observing the behavioral pattern of reducer programs for data analytics, we characterize the essential components in a programming language for reducers. %However, we found that even only with the essential parts of the language, the commutativity problem is still undecidable. 
Inspired by~\cite{RP11}, we found that the commutativity problem becomes decidable if we partition variables into \emph{control variables} and \emph{data variables}. Data variables cannot be used in transition guards and control variables can store only elements in the input list (e.g., it is not allowed to store the sum of two variables in a control variable). 
We believe such concepts provide good insights for reducer programming language design.

We define a formalism named \emph{streaming numerical transducers (SNT)} and use it to create a decision procedure for the reducer commutative problem.
SNTs combine the features of register automata~\cite{XX} and vector addition system with states (VASS)~\cite{YY} with restrictions on the structure of the transition systems.
We show that the equivalence, commutative, and non-zeroness problems of generalized flat SNTs are decidable.
Moreover, SNTs can be composed to form a commutative/equivalence proof of reducer programs that read the input list multiple times.
On theoretical point of view, the study of deterministic SNT is
interesting on its own right. It is tightly related to both register automata and integer VASS and the decidability of its decision problems are seemingly non-trivial. 

The rest of the paper is organized as follows. Section~\ref{sec:preliminaries} describes design of the streaming numerical transducer model, including the formal definition, the rationale behind the model design, and the types of data analytics reducer programs it can express. Section~\ref{sec:decision} discusses the decision problems and the procedure for solving the problems.

\section{Preliminaries}
%
Let $\intnum$ be the set of integers and $\bot \not \in \intnum$ be 
the undefined value. By convention, it is assumed that $\bot + \bot = \bot$, $\bot + n = \bot$ for each $n \in \intnum$, $0 \times \bot = 0$, and $n \times \bot = \bot$ for each $n \in \intnum \setminus \{0\}$.
In this paper, we assume that all variables range over $\intnum \cup \{\bot\}$.  

For a function $\pi$, let $\dom(\pi)$ and $\rng(\pi)$ denote the domain  and range of $\pi$ respectively. 
An \emph{expression} $e$ over variables $Z$ is defined by the following rules, $e\equiv  z \mid c \mid e + e \mid e - e$, where $z \in Z$ and $c\in \intnum$. 
For an expression $e$, let $\vars(e)$ denote the set of variables occurring in $e$. Let $\Ee_Z$ denote the set of all expressions over variables $Z$. Let $e$ be an expression and $\eta$ be a partial function from $\vars(e)$ to $\Ee$. Then we use $\sub{e}{\eta}$ to denote the expression obtained from $e$ by replacing each variable $z \in \vars(e)\cap\dom(\eta)$ with $\eta(z)$. A \emph{valuation} $\rho$ of variables $Z$ is a function from $Z$ to $\intnum \cup \{\bot\}$. The value of $e$ under $\rho$, denoted by $\sub{e}{\eta}$, is defined as the value obtained by replacing each variable $z \in \vars(e)$ with $\rho(z)$.

A \emph{guard} over variables $Z$ is a function from $Z$ to $\intnum \cup \{\bot\}$. Let $\rho$ be a valuation and $g$ be a guard. Then $\rho$ satisfies $g$, denoted by $\rho \models g$, iff for each variable $z \in Z \cap \vars(g)$, $\rho(z) \neq \bot$, and $g$ is evaluated to $\ltrue$ under $\rho$. 

\hide{
==========backup

Moreover, let $X,Y$ denote another two finite sets of variables ranging over $\intnum \cup \{\bot\}$ such that $\intvars \cap X =\intvars \cap Y = X \cap Y = \emptyset$. We also use another special variable $\cur \not \in \intvars \cup X \cup Y$ (to denote the current data value). A \emph{guard} over $X \cup \{\cur\}$ is a formula defined by the following rules, $g::= \ltrue \mid \cur\ o\ c \mid \cur\ o\ x \mid g \wedge g$, where $o \in \{=,\neq,<, >, \le, \ge\}$, $x \in X$, and $c$ is a constant over $\intnum$. An \emph{arithmetic expression} $e$ is defined by the following rules, $e::=  z \mid c \mid e + e \mid e - e$, where $z \in \intvars \cup X \cup Y \cup \{\cur\}$, and $c$ is a constant over $\intnum$. For an expression $e$, let $\vars(e)$ denote the set of variables occurring in $e$. Let $\Ee$ denote the set of all arithmetic expressions. Let $e$ be an expression and $\eta$ be a partial function from $\intvars \cup X \cup Y \cup \{\cur\}$ to $\Ee$ such that $\vars(e) \subseteq \dom(\eta)$. Then we use $\eta(e)$ to denote the expression obtained from $e$ by replacing each variable $z \in \vars(e)$ with $\eta(z)$. An \emph{assignment} $\eta$ for $X \cup Y$ is a partial function from $X \cup Y$ to $\Ee_{X \cup Y \cup \{\cur\}}$ such that for each $x \in X \cap \dom(\eta)$, $\eta(x)=\cur$. 

A \emph{valuation} $\rho$ of $X \cup Y \cup \{\cur\}$ is a function from $X \cup Y \cup \{\cur\}$ to $\intnum \cup \{\bot\}$. Let $\rho$ be valuation, $g$ be a guard, and $e \in \Ee_{X \cup Y \cup \{\cur\}}$. Then $\rho$ satisfies $g$, denoted by $\rho \models g$, iff for each variable $z \in (X \cup \{\cur\}) \cap \vars(g)$, $\rho(z) \neq \bot$, and the evaluation of $g$ under $\rho$ results in the value $\ltrue$. Moreover, the value of $e$ under $\rho$, denoted by $\rho(e)$, is defined as the value obtained by replacing each variable $z \in \vars(e)$ with $\rho(z)$. 

A data word $w$ is a sequence of integer values $d_1\dots d_n$ such that $d_i \in \intnum$ for each $i$.
}
\section{Language For Integer Reducers}\label{sec-mr-prog}
We discuss the rationale behind the design of the programming language for reducers such that the commutativity problem is decidable.
We focus on a language that only allow to iterate though the input list once. Later we will show an extension that allows the reset of list iterators.



\begin{figure}
	\centering
	\begin{tabular}{rcl}
		$g,g_1,g_2 \in Guard$&$\equiv$&$ cur()>x \mid cur()=x \mid x>c \mid x=c \mid \neg g \mid g_1\wedge g_2$\\
		$e,e_1,e_2 \in Expressions$&$\equiv$&$cur()\mid c\mid x\mid e_1+e_2  \mid e_1 - e_2$\\
		$ s_1,s_2,s_3 \in Statements$&$\equiv$&$y := e\mid y := y+e\mid x:=cur()\mid x_1:=x_2\mid s_1;s_2\mid next()\mid $\\
		&& $ \mbox{return UFLIA}(X\cup Y)\mid \mbox{if(} g \mbox{)then\{} s_1;\mbox{\}else\{}s_2;\mbox{\}}$\\
		$ Programs$&$\equiv$&$(s_1;)^*\mbox{while(}cur()\neq end() \mbox{)\{} s_2;\mbox{\}}(;s_3)^*$		
	\end{tabular}
	\label{fig:language}
	\caption{A Simple Programming Language for Reducers. Here $x_1,x_2,x\in X$ are control variables, $y\in Y$ is a data variable, $\mbox{UFLIA}(S)$ is a quantifier free linear integer arithmetic formula with uninterpreted function over variables in $S$, and $c\in \mathbb{Z}$.}
\end{figure}

To be more concrete, we focus on the programming language in Figure~\ref{fig:language}.
The main feature of the language is that we partition the variables into two sets: \emph{control variables} and \emph{data variables}.
The former are used for guiding the program flow and the latter used for storing aggregated results.
To be more specific, the control variables can store only values occurred in the input and can be used either in guard or arithmetic expressions.
The data variables can store the results obtained from an arithmetic expression, but cannot be used either in guards or arithmetic expressions.

Note that we do not allow multiplication in the language, so the reduction from the satisfiability of Diophantine equations no longer works. Even though, if we do not distinguish the control and data variables, we can show easily that basic decision problems such as for this language is still undecidable, by a reduction from the reachability problem of perti-net with zero test~\cite{petri}.
Intuitively, variables are used for remembering the number of tokens in each place. Transitions between places can be described as assignments to variables. The transitions are described by the loop body: each loop iteration makes a petri-net transition. 
The non-determinism in transitions is expressed by branching over the input. 
The guards in transitions are expressed by branching over the variables, respectively (recall that we are discussing the version that we do not distinguishing data and control variables). Then the reachability problem of perti-net with zero test can be reduced to reachability problem in the programming language.


Notice that in the programming language, we allow only either adds or assigns a new value to data variables ($y := e$ and $y := y+e$). We argue that this is sufficient for reducers performing data analytics operations.
In Figure~\ref{fig:examples} we demonstrate a few simple examples of . Observe that all of them follow the same behavioral pattern: the program iterates through the input list and aggregates the processed result in some variables. The operation used for the aggregation is usually ratter simple: it either adds a new value (like the case \texttt{avg}) or assigns a new value (like the cases {\texttt max\_abs} and {\texttt 2nd\_largest}) to the variable storing the aggregated result. Actually, the same behavioral pattern occurs in all the programs we have investigated.

The observation is actually not a big surprise. The \emph{reduce} operation in Map-Reducer has a tight relation with the \emph{fold} operation in functional languages, which aggregates the values in a list using a binary function and returns one value. Here the data variables are used for storing the aggregated results. Since we allows only add and subtract operations in the programming language, we do not need more than ``adds/assigns a value to data variables'' to describe the binary function in fold operations. We argue that this is enough to describe this is sufficient to describe programs that can be described by the \emph{fold} operation in functional languages.

One may argue that allowing only add and substrate is too restrictive for data analytics. For many cases with multiplication and subtractions, we can model them using \emph{uninterpreted functions}. For example, in Figure~\ref{fig:examples}(b), we can model the subtraction in the return expression using uninterpreted functions.

 and obtain a sound procedure for verifying commutativity. 

//to be continue, explain the UFLIA thing at the end of the programming language.

\begin{figure}
	\centering
	\lstset{language=C,
		basicstyle=\ttfamily\scriptsize}
	\begin{tabular}{|c|c|c|}
\hline
		\begin{minipage}[t]{0.28\textwidth}
			(a)
			\begin{lstlisting}[mathescape=true]
int max_abs() {
 if(cur()>0){
   max:=cur();
 }else{
   max:= -cur();
 }
 next();
 while(cur()$\neq$end()){
  if(cur()>0){
   if(cur()>max){
    max:=cur();
   }
  }else{
   if(-cur()>max){
    max:=-cur();
   }  
   next();
  }
  return max;
}
			\end{lstlisting}
		\end{minipage}&
		\begin{minipage}[t]{0.28\textwidth}
			(b)
			\begin{lstlisting}[mathescape=true]
int avg() {
 sum:=cur();
 cnt:=0;
 next();
 while(cur()$\neq$end()){
  sum:=sum+cur();
  cnt+=cnt+1;
  next();
 };
 return sum/cnt;
}
			\end{lstlisting}
		\end{minipage}&
		\begin{minipage}[t]{0.29\textwidth}
		(c) 
	\begin{lstlisting}[mathescape=true]
int 2nd_largest() {
 a:=cur();
 b:=cur();
 next();
 if(cur()>a){
  a:=cur();
 }else{
  b:=cur();
 }
 next();
 while(cur()$\neq$end()){
  if(cur()>a){
   b:=a;
   a:=cur();
  }else{
   if(cur()>b){
    b:=cur();
   }   
  }
  next();
 }
 return b;
}
	\end{lstlisting}		
		\end{minipage}\\
\hline		
	\end{tabular}
	\label{fig:examples}
	\caption{Examples of Reducers Performing Data Analytics Operations}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%streaming numerical transducer%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Streaming Numerical Transducers}\label{sec-def-snt}

In this section, we introduce streaming numerical transducers, whose inputs are data words and outputs are integer values. Over a data word, a streaming numerical transducer scans the data word from left to right, records some information by using control and data variables, and outputs a data value when it arrives at the right end of the data word. We will use streaming numerical transducers to decide the commutativity problem of the MapReduce programs defined in Section~\ref{sec-mr-prog}.

We first give definitions of notations used in this section.
Let $\intvars$ be an infinite set of variables. Moreover, let $X,Y$ denote another two finite sets of variables ranging over $\intnum \cup \{\bot\}$ such that $\intvars \cap X =\intvars \cap Y = X \cap Y = \emptyset$. We also use another special variable $\cur \not \in \intvars \cup X \cup Y$ (to denote the current data value). 
A \emph{guard} over $X \cup \{\cur\}$ is a formula defined by the following rules, $g::= \ltrue \mid \cur\ o\ c \mid \cur\ o\ x \mid g \wedge g$, where $o \in \{=,\neq,<, >, \le, \ge\}$, $x \in X$, and $c$ is a constant over $\intnum$. 
We assume in this section expressions are over $\intvars \cup X \cup Y \cup \{\cur\}$.
\yfc{I moved from section 2 definitions that are only used in SNT. I left only general definition there}

A \emph{streaming numerical transducer} (SNT) $\Ss$ is a tuple $(Q, X, Y, \delta, q_0, O)$ such that 
\begin{itemize}
\item $Q$ is a finite set of states,
%
\item $X$ is a finite set of control variables to store some data values that have been met,
%
\item $Y$ is a finite set of data variables to aggregate some information for the output,
%
\item $\delta$ comprises the tuples $(q,  g, \eta, q')$, where $q,q'\in Q$, $g$ is a guard over $X$ (note that the variables from $Y$ do not occur in $g$), and $\eta$ is an assignment for $X \cup Y$, 
%
\item $q_0 \in Q$ is the initial state,
%
\item $O$ is the output function, which is a partial function from $Q$ to $\Ee_{X \cup Y}$.
\end{itemize}
Moreover, we assume that the SNT $\Ss$ satisfies the following constraints.
\begin{description}
\item [1 (Deterministic).] For each pair of distinct transitions originating from $q$, say $(q, g_1, \eta_1,q'_1)$ and $(q, g_2,\eta_2,q'_2)$, it holds that $g_1$ and $g_2$ are mutually exclusive, that is, $g_1 \wedge g_2$ is unsatisfiable.
%
\item [2 (Generalized flat).] Each SCC (strongly connected component) of the transition graph of $\Ss$ is either a single state or a collection of cycles that share a unique state.
%
%\item[3 (Independently evolving).] For each $(q, g, \eta, q') \in \delta$ and each $y \in Y$, $\eta(y)$ contains no variables $y' \in Y$ such that $y' \neq y$.
%
\item[3 (Independently evolving and copyless).] For each $(q, g, \eta, q') \in \delta$ and each $y \in Y \cap \dom(\eta)$, either $\vars(\eta(y)) \subseteq X \cup \{\cur\}$ or $\eta(y)=y+e$ for some expression $e$ such that $\vars(e) \subseteq X \cup \{\cur\}$. \zhilin{I forbid the assignments $\eta(y)=-y+e$.}
%
\end{description}

For a transition $(q,g,\eta,q') \in \delta$, we usually write it as $q \xrightarrow{(g,\eta)} q'$, in a more intuitive way.

The semantics of a SNT $\Ss$  is defined as follows: A \emph{configuration} of $\Ss$ is a pair $(q,\rho)$, where $q \in Q$ and $\rho$ is a valuation of $X \cup Y$. The \emph{initial} configuration of $\Ss$ is $(q_0,\rho_0)$, where $\rho_0(x)=\bot$ and $\rho_0(y)=\bot$ for each $x \in X$ and $y \in Y$. Over a data word $w=d_1 \dots d_n$, a \emph{run} of $\Ss$ over $w$ is a sequence of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2 \dots q_{n-1} \xrightarrow{(g_n, \eta_n)} q_n$ such that for each $i: 1 \le i \le n$, $\rho_{i-1}[d_i/\cur]  \models g_i$, and $\rho_i$ is obtained from $\rho_{i-1}$ as follows,
\begin{itemize}
\item for each $x \in X$, if $ x \in \dom(\eta_i)$, then $\rho_i(x)=d_i$, otherwise, $\rho_i(x)=\rho_{i-1}(x)$,
%
\item for each $y \in Y$, if $y \in \dom(\eta_i)$, then $\rho_i(y)=(\rho_{i-1}[d_i/\cur])(\eta_i(y))$, otherwise, $\rho_i(y)=\rho_{i-1}(y)$,
\end{itemize}
where $\rho_{i-1}[d_i/\cur]$ is the extension of $\rho_{i-1}$ by assigning $d_i$ to $\cur$. We will call $(q_n,\rho_n)$ as the \emph{final configuration} of the run.

We would like to remark that for each data word $w$, there is at most one run of $\Ss$ over $w$, since $\Ss$ is deterministic. 

Over a data word $w = d_1 \dots d_n$, if there is a run of $\Ss$ over $w$ with the final configuration $(q_n,\rho_n)$, and $O(q_n)$ is defined, then the output of $\Ss$ over $w$, denoted by $O_{\Ss}(w)$, is $\rho_n(O(q_n))$. Otherwise, $O_{\Ss}(w)$ is $\bot$.

\begin{example}[SNT for max and sum]
The SNT to define the maximum of the integers occurring in a data word is given by $\Ss_{\max}=(\{q_0,q_1\}, \{\maxv\}, \emptyset, \delta, q_0, O)$  such that $\delta = \{(q_0, \ltrue, \maxv:=\cur, q_1), (q_1, \maxv < \cur, \maxv:=\cur,q_1), (q_1, \maxv \ge \cur, \eta_\bot, q_1)\}$, and $O(q_1)=\maxv$, where $\maxv:=\cur$ denotes the function that assigns $\cur$ to $\maxv$, and $\eta_\bot$ denotes the assignment function of the empty domain. The SNT to define the sum of the integers occurring in a data word is given by $\Ss_{\mathrm{sum}}=(\{q_0,q_1\}, \emptyset, \{\sumv\}, \delta, q_0, O)$ such that $\delta=\{(q_0, \ltrue, \sumv:=\cur, q_1), (q_1, \ltrue, \sumv:=\sumv + \cur, q_1)$, and $O(q_1)=\sumv$. 
\end{example}

\begin{proposition}\label{prop-mrprog-to-snt}
For each MapReduce program XX, an equivalent SNT can be constructed. \zhilin{to be cleaned, once the definition of MR programs fixed}
\end{proposition}

%\begin{example}[Example inspired by Pagerank]
%The following transducer sum all the data values, except the last position, then it outputs a concatenation of the sum and the last tuple: $(q_0, 1, true, sum:= sum + p_1, q_0)$, $(q_0, k, true, (x_i:=p_i)_{1 \le i \le k}, q_1)$, $O(q_1)=(sum, x_1,\dots, x_k)$.
%\end{example}


We introduce a concept of ``well-defined'' for SNTs. Let $\Ss=(Q,X,Y,\delta,q_0,O)$ be an SNT. Then $\Ss$ is said to be \emph{well-defined} if for each data word $w=d_1\dots d_n$ and each run of $\Ss$ over $w$, say  $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \dots q_{n-1} \xrightarrow{g_n,\eta_n} q_n$, let $(q_0,\rho_0),\dots,(q_n,\rho_n)$ be the resulting sequence of configurations, then the following conditions hold: for each $i: 1 \le i \le n$ and each $z \in X \cup Y$ occurring in $(g_i,\eta_i)$, we have $\rho_{i-1}(z) \neq \bot$, moreover, if $O(q_n)$ is defined, then for each variable $z$ occurring in $O(q_n)$, we have $\rho_{n}(z) \neq \bot$.

From now on, we assume that all SNTs are well-defined. Otherwise, we can construct an equivalent well-defined SNT $\Ss'=(Q', X,Y, \delta', (q_0,\emptyset), O')$, where 
\begin{itemize}
\item $Q' = Q \times 2^X$,
%
\item $\delta'$ comprises the tuples $((q,Z),g,\eta,(q', Z'))$ such that $(q,g,\eta,q') \in \delta$ and $Z' = Z \cup (X \cap \dom(\eta)) \cup \{y \in Y \cap \dom(\eta) \mid \vars(\eta(y)) \subseteq Z \cup \{\cur\}\}$ (intuitively, suppose that the values of the variables from $Z$ are defined before a transition $(q,g,\eta,q')$, then $Z'$ is the set of variables whose values are defined after applying the transition),
%
\item for each $(q,Z) \in Q'$, if $O(q)$ is defined and $\vars(O(q)) \subseteq Z$, then $O'((q,Z))=O(q)$, otherwise, $O((q,Z))$ is undefined.
\end{itemize} 

Note that if a SNT $\Ss$ is well-defined, then for each data word $w$, if the run of $\Ss$ over a data word $w$ reaches a state $q$ and $O(q)$ is defined, then the output of $\Ss$ over $w$ is defined.

%We first compute a fixed point $\defval$ inductively as follows. 
%\begin{enumerate}
%\item Initially, let $\defval_0=\{(q_0,\emptyset)\}$.
%
%\item For each $i > 0$, compute $\defval_i$ from $\defval_{i-1}$ as follows,
%\begin{itemize}
%\item each element of $\defval_{i-1}$ is an element of $\defval_i$, 
%
%\item for each $(q,Z) \in \defval_{i-1}$ and each transition $(q,g,\eta,q') \in \delta$,  let $Z' = Z \cup (X \cap \dom(\eta)) \cup \{y \in Y \cap \dom(\eta) \mid \vars(\eta(y)) \subseteq Z \cup \{\cur\}\}$, put $(q',Z')$ into $\defval_i$.
%\end{itemize}
%
%\item If $\defval_{i-1}=\defval_i$, then the computation stops, otherwise, let $i:=i+1$ and the computation continues.
%\end{enumerate}




We focus on the following three decision problems of SNTs in this paper, the commutativity problem, the equivalence problem, and the non-zero output problem.
\begin{description}
\item[(Commutativity).] Given a SNT $\Ss$, decide whether $\Ss$ is commutative, that is, whether for each data word $w$ and each permutation $w'$ of $w$, the output of $\Ss$ over $w$ is equal to that of $\Ss$ over $w'$.
%
\item[(Equivalence).] Given two SNTs $\Ss_1,\Ss_2$, decide whether $\Ss_1$ and $\Ss_2$ are equivalent, that is, whether over each data word $w$, $O_{\Ss_1}(w)=O_{\Ss_2}(w)$.
%
\item[(Non-zero output reachability).] Given a SNT $\Ss$, decide whether $\Ss$ has a non-zero output, that is, whether there is an input $w$ such that $O_{\Ss}(w) \neq \bot$ and $O_{\Ss}(w)$ is non-zero. 
\end{description}
In the following, we show that the commutativity problem can be reduced to the equivalence problem, which in turn can be reduced to the non-zero output reachability problem.


\begin{proposition}\label{prop-snt-cmm-to-eqv}
The commutativity problem of SNTs is reduced to the equivalence problem of SNTs in exponential time. 
\end{proposition}

The equivalence problem of SNTs can be further reduced to the non-zero output reachability problem of SNTs.

\begin{proposition}\label{prop-snt-eqv-to-nzero}
From SNT $\Ss_1$ and $\Ss_2$, a SNT $\Ss_3$ can be constructed in polynomial time such that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss_3$ over $w$ is nonzero. 
\end{proposition}



\section{Decision procedure for the non-zero output reachability problem}\label{sec-dec-snt}

In this section, we present a decision procedure for the non-zero output reachability problem of SNTs. 

We first assume that the guards of the transitions do not contain the comparisons with integer constants and illustrate the main ideas of the decision procedure as follows.
\begin{enumerate}
\item  We first show how to summarize the computations over paths and cycles. 
%
\item We present an algorithm to decide the non-zero output reachability problem for the situation that the transition graph of the given SNT  is a generalized lasso. A \emph{generalized lasso} is an extension of lasso where the cycle is replaced by a collection of cycles such that there is a state $q$ which is the unique common state of each pair of distinct cycles.
%
\item We demonstrate how to extend the algorithm to the more general situation that the transition graph of the given SNT is generalized flat.
\end{enumerate}
Finally, we will show how to adapt the algorithm for the situation that the guards of the transitions may contain the comparisons with integer constants.

At first, we normalize the SNTs in order to facilitate the presentation of the decision procedure.

Suppose $\Ss=(Q,X,Y,\delta,q_0,O)$ is a SNT. Let $c_{min}$ and $c_{max}$ denote the minimum resp. maximum integer constant occurring in the guards of the transitions of $\Ss$. 

A SNT $\Ss=(Q,X,Y,\delta,q_0,O)$ is said to be \emph{normalized} if the following two constraints are satisfied.
\begin{itemize}
\item For each $(q,g,\eta,q') \in \delta$, if $\eta(x)=\cur$ for some $x \in X$, then the guard $g$ implies $\bigwedge \limits_{x \in X} \cur \neq x$.  Intuitively, when the current data value is stored into some control variable, it is required that the data value is distinct from all the data values that have already been stored in the control variables.
%
\item For each $(q, g, \eta, q') \in \delta$, the guard $g$ includes one of the following formulae as a conjunct: $\cur < c_{min}$, or $\cur = c$ for $c_{min} \le c \le c_{max}$, or $\cur > c_{max}$.
\end{itemize}


\begin{proposition}\label{prop-snt-norm}
From each SNT, an equivalent normalized SNT can be constructed in exponential time. 
\end{proposition}

From now on, we assume that all SNTs are normalized. 

In the rest of this section, we fix a (normalized) SNT $\Ss = (Q,X,Y,\delta,q_0,O)$ such that $X=\{ x_1,\dots, x_k\}$ and $Y = \{y_1,\dots,y_l\}$. Moreover, in the next three subsections, we assume that the guards of the transitions of $\Ss$ contain no comparisons with constants. In the last subsection, we will consider the more general situation. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Summarization of the computations on paths and cycles}

Suppose $P=p_0 \xrightarrow{(g_1,\eta_1)} p_1 \dots p_{n-1} \xrightarrow{(g_n,\eta_n)} p_{n}$ is a path in $\Ss$ (not necessarily starting from the initial state). 

Suppose that the initial values of the $k$ control variables are represented by $d_1,\dots, d_k$ and the $n$ data values met when traversing the path are represented by $d_{k+1},\dots,d_{k+n}$ (these data values may repeat). Then the guards and the assignments in the path induce an equivalence relation $\sim$ on $\{1,\dots, k+n\}$ so that  $i \sim j$ iff it can be inferred from the guards and assignments that $d_i = d_j$. Since $\Ss$ is normalized, we know that for each pair of indices $i,j: 1 \le i < j \le k+n$ such that $i \sim j$, it holds that $j \ge k+1$. Let $I_1,\dots, I_{k+r}$ be an enumeration of the equivalence classes of $\sim$ on $\{1,\dots, k+n\}$ such that $\min(I_1) < \dots < \min(I_{k+r})$. Then for each $j: 1 \le j \le k$, $\min(I_j)=j$.

Suppose that the initial values of the $k$ control variables are denoted by the variables $d^{(0)}_1,\dots,d^{(0)}_k$ respectively. Moreover, suppose that the $r$ fresh data values that are introduced when traversing the path are denoted by the variables $d^{(1)}_{1},\dots,d^{(1)}_{r}$, with one data value for each of $I_{1},\dots,I_{r}$. 
In addition, suppose that the initial values of $y_1,\dots, y_l$ are denoted by the variables $o_1,\dots,o_l$ respectively. 

\begin{proposition}\label{prop-sum-path}
The values of the control and data variables after traversing the path $P$ are specified by a function $\chi$ satisfying the following conditions.
\begin{itemize}
\item There is an injective mapping $\pi: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi(j) \le k$, then $\pi(j)=j$ and $\chi(x_j)=d^{(0)}_{j}$, otherwise, $\chi(x_j)=d^{(1)}_{\pi(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi(y_j) = \alpha_{j,0} + \alpha_{j,1} o_j + \beta_{j,1} d^{(0)}_1 + \dots + \beta_{j,k} d^{(0)}_k + \gamma_{j,1} d^{(1)}_1 +\dots + \gamma_{j,r} d^{(1)}_{r}$ for some constants $\alpha_{j,0},\alpha_{j,1}, \beta_{j,1},\dots,\beta_{j,k}, \gamma_{j,1},\dots,\gamma_{j,r}$ such that $\alpha_{j,1} \in \{0,+1\}$ (as a result of the ``independently evolving and copyless'' constraint).
\end{itemize}
\end{proposition}

Suppose $\{d^{(0)}_1,\dots,d^{(0)}_k, o_1,\dots,o_l, d^{(1,1)}_1,\dots,d^{(1,1)}_{r_1}, d^{(2,1)}_1,\dots,d^{(2,1)}_{r_2}\}$ are a set of pairwise distinct variables from $\intvars$. For $b=1,2$, let 
\[\Zz_b=\{d^{(0)}_1,\dots,d^{(0)}_k, o_1,\dots,o_l, d^{(b,1)}_1,\dots,d^{(b,1)}_{r_b}\},\] and $\chi_b$ be a function from $X \cup Y$ to $\Ee_{\mathcal{Z}_b}$. Then the \emph{composition} of $\chi_1$ and $\chi_2$, denoted by $\chi_1 \circ \chi_2$, is defined as follows: Let $\chi'_1$ be a function with the domain $\{d^{(0)}_1,\dots,d^{(0)}_k, o_1,\dots,o_l\}$ such that for each $j: 1 \le j \le k$ (resp. $j: 1 \le j \le l$), $\chi'_1(d^{(0)}_j)=\chi_1(x_j)$ (resp. $\chi'_1(o_j)=\chi_1(y_j)$). Then
\begin{itemize}
\item for each $x_j \in X$, if $\chi_2(x_j) = d^{(0)}_j$, then $(\chi_1 \circ \chi_2)(x_j)=\chi'_1(\chi_2(x_j)) = \chi'_1(d^{(0)}_j)=\chi_1(x_j)$, otherwise, $(\chi_1 \circ \chi_2)(x_j)=\chi_2(x_j)$,
%
\item for each $y_j \in Y$, $(\chi_1 \circ \chi_2)(y_j)=\chi'_1(\chi_2(y_j))$.
\end{itemize}

\begin{corollary}\label{cor-comp-two-paths}
Suppose that $P_1$ and $P_2$ are two paths in $\Ss$ such that $p^{(1)}_{n_1}=p^{(2)}_0$. Moreover, let $\chi_1$ (resp. $\chi_2$) be the function summarizing the computation of $\Ss$ on $P_1$ (resp. $P_2$). Then the function summarizing the computation of $\Ss$ over the path $P_1 P_2$ is $\chi_1 \circ \chi_2$.
\end{corollary}

In order to get a better understanding of the relationship between $(\chi_1 \circ \chi_2)$ and $\chi_1,\chi_2$, we apply a refined analysis of $\chi_1 \circ \chi_2$ in the following. 

From Proposition~\ref{prop-sum-path}, for $b=1,2$, we assume that $\chi_b$ is defined as follows.
\begin{itemize}
\item There is an injective mapping $\pi_b: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi_b(j) \le k$, then $\pi_b(j)=j$ and $\chi_b(x_j)=d^{(0)}_{j}$, otherwise, $\chi_b(x_j)=d^{(b,1)}_{\pi_b(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi_b(y_j) = \alpha^{(b)}_{j,0} + \alpha^{(b)}_{j,1} o_j + \beta^{(b)}_{j,1} d^{(0)}_1 + \dots + \beta^{(b)}_{j,k} d^{(0)}_k + \gamma^{(b)}_{j,1} d^{(b,1)}_1 +\dots + \gamma^{(b)}_{j,r_b} d^{(b,1)}_{r_b}$ such that $\alpha^{(b)}_{j,1} \in \{0,+1\}$.
\end{itemize}

Then
for each $y_j \in Y$,
\[
\begin{array}{l c l}
\medskip
(\chi_1 \circ \chi_2)(y_j) & = & \chi'_1(\chi_2(y_j))\\
%& = & \chi'_1(\alpha^{(2)}_{j,0} + \alpha^{(2)}_{j,1} o_j + \beta^{(2)}_{j,1} d^{(0)}_1 + \dots + \beta^{(2)}_{j,k} d^{(0)}_k + \\
%& & \hspace{8mm} \gamma^{(2)}_{j,1} d^{(2,1)}_1 +\dots + \gamma^{(2)}_{j,r_2} d^{(2,1)}_{r_2})\\
%
& = &  \alpha^{(2)}_{j,0} + \alpha^{(2)}_{j,1} \chi_1(y_j) + \beta^{(2)}_{j,1} \chi_1(x_1) + \dots + \beta^{(2)}_{j,k} \chi_1(x_k) +\\
\medskip
& & \gamma^{(2)}_{j,1} d^{(2,1)}_1 +\dots + \gamma^{(2)}_{j,r_2} d^{(2,1)}_{r_2} \\
%
& =  & (\alpha^{(2)}_{j,0}+\alpha^{(2)}_{j,1} \alpha^{(1)}_{j,0})+ (\alpha^{(2)}_{j,1}\alpha^{(1)}_{j,0}) o_j + \\
%
& & \sum \limits_{j' \le k, \pi_1(j')=j'} (\beta^{(2)}_{j,j'}+\alpha^{(2)}_{j,1} \beta^{(1)}_{j,j'}) d^{(0)}_{j'} + \sum \limits_{j' \le k, \pi_1(j') \neq j'} (\alpha^{(2)}_{j,1} \beta^{(1)}_{j,j'}) d^{(0)}_{j'}  \\
%
& & + \sum \limits_{j' \le r_1, j' + k \in \rng(\pi_1)} (\beta^{(2)}_{j,\pi_1^{-1}(j'+k)}+\alpha^{(2)}_{j,1} \gamma^{(1)}_{j,j'}) d^{(1,1)}_{j'} +\\
%
& & \sum \limits_{j' \le r_1, j' + k \not \in \rng(\pi_1)} (\alpha^{(2)}_{j,1} \gamma^{(1)}_{j,j'}) d^{(1,1)}_{j'} + 
 \gamma^{(2)}_{j,1} d^{(2,1)}_1 +\dots + \gamma^{(2)}_{j,r_2} d^{(2,1)}_{r_2}.
\end{array}
\] 

In the following, for each path $P=C^{\ell}$ which is obtained by iterating a cycle $C$ for $\ell$ times, we provide an analysis of the computation of $\Ss$ on $P$.

Suppose that $C$ is a cycle in $\Ss$, that is, a path $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \dots q_{n-1} \xrightarrow{(g_n, \eta_n)} q_n$ such that $q_n = q_0$.  

Suppose the initial values of the $k$ control variables are $d^{(0)}_1,\dots,d^{(0)}_k$. Moreover, suppose that the $r_C$ data values $d^{(C,1)}_{1},\dots,d^{(C,1)}_{r_C}$ are introduced when traversing the cycle for the first time. 
In addition, suppose that the initial values of $y_1,\dots, y_l$ are $o_1,\dots,o_l$. 

From Proposition~\ref{prop-sum-path}, we know that a function $\chi_C$ can be constructed to summarize the computation of $\Ss$ on $C$.
\begin{itemize}
\item There is an injective mapping $\pi_C: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi_C(j) \le k$, then $\pi_C(j)=j$ and $\chi_C(x_j)=d^{(0)}_{j}$, otherwise, $\chi_C(x_j)=d^{(C,1)}_{\pi_C(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi_C(y_j) = \alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} o_j + \beta^{(C)}_{j,1} d^{(0)}_1 + \dots + \beta^{(C)}_{j,k} d^{(0)}_k + \gamma^{(C)}_{j,1} d^{(C,1)}_1 +\dots + \gamma^{(C)}_{j,r_C} d^{(C,1)}_{r_C}$ such that $\alpha^{(C)}_{j,1} \in \{0,+1\}$.
\end{itemize}

\begin{proposition}\label{prop-sum-cycle}
Suppose $P=C^{\ell}$ such that $\ell \ge 2$. Then the function $\chi^{(C)}_{\ell}$ to summarize the computation of $\Ss$ on $P$ is defined as follows,
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0}+ \dots +(\alpha^{(C)}_{j,1})^{\ell-1} \alpha^{(C)}_{j,0}) + (\alpha^{(C)}_{j,1})^\ell o_j + \\
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1}\beta^{(C)}_{j,j'} + \dots +(\alpha^{(C)}_{j,1})^{\ell-1}  \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \\
%
& & \sum \limits_{j'\le k, \pi_C(j') \neq j'} ((\alpha^{(C)}_{j,1})^{\ell-1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( (\alpha^{(C)}_{j,1})^{\ell-2} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +(\alpha^{(C)}_{j,1})^{\ell-1}\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} ((\alpha^{(C)}_{j,1})^{\ell-1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1}\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C},
\end{array} 
\]
where $d^{(C,2)}_{1},\dots, d^{(C,2)}_{r_C},\dots, d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$
 are the data values introduced when traversing $C$ for the second time, $\dots$, and for $\ell$ times.
\end{proposition}

From Proposition~\ref{prop-sum-cycle} and the fact that $\alpha_{j,1} \in \{0,+1\}$, for $\ell \ge 2$, we deduce the following facts.
\begin{itemize}
\item If $\alpha^{(C)}_{j,1}=0$, then
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & \alpha^{(C)}_{j,0} +  \sum \limits_{j' \le k, \pi_C(j')=j'} \beta^{(C)}_{j,j'} d^{(0)}_{j'} +
\\
\smallskip
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} d^{(C,\ell-1)}_{j'} + \\
& & \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
\item If $\alpha^{(C)}_{j,1}=1$, then 
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} \ell) + o_j +   \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'} \ell) d^{(0)}_{j'} + \sum \limits_{j'\le k, \pi_C(j') \neq j'} \beta^{(C)}_{j,j'} d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)} + \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} \gamma^{(C)}_{j,j'} d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} \gamma^{(C)}_{j,j'} d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
%
\hide{
\item If $\alpha^{(C)}_{j,1}=-1$ and $\ell$ is even, then
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = &  o_j + \sum \limits_{j'\le k, \pi_C(j') \neq j'} (-\beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} - \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (-\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
\item If $\alpha_{j,1}=-1$ and $\ell$ is odd, then
\[
\begin{array}{l c l}
\smallskip
\chi^{(C)}_{\ell}(y_j)  & = &  \alpha^{(C)}_{j,0} - o_j + \sum \limits_{j' \le k, \pi_C(j')=j'} \beta^{(C)}_{j,j'} d^{(0)}_{j'} +  \sum \limits_{j'\le k, \pi_C(j') \neq j'}  \beta^{(C)}_{j,j'} d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( -\beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} \gamma^{(C)}_{j,j'} d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (-\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C}.
\end{array} 
\]
}
\end{itemize}
%
From the analysis above, we observe that in $\chi^{(C)}_\ell(y_j)$, 
\begin{itemize}
\item the constant coefficient is either $\alpha^{(C)}_{j,0}$, or $\alpha^{(C)}_{j,0} \ell$, 
%
\item the coefficient of $o_j$ is $0$, or $1$, 
%
\item for each data value $d^{(0)}_{j'}$, the coefficient of $d^{(0)}_{j'}$ is either $\beta^{(C)}_{j,j'}$, or $0$, or $\beta^{(C)}_{j,j'} \ell$,
%
\item for each data value $d^{(C,i)}_{j'}$ with $i \ge 1$, the coefficient of $d^{(C,i)}_{j'}$ is either $0$, or $\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}$, or $\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\gamma^{(C)}_{j,j'}$, or $\gamma^{(C)}_{j,j'}$.
\end{itemize}


\subsection{Decision procedure for generalized lassos}

In this subsection, we present a decision procedure for the situation that the transition graph of $\Ss$ is a generalized lasso. 

Suppose the transition graph of $\Ss$ comprises a handle $H=q_0 q_1 \dots q_m$ and a collection of simple cycles $C_1,\dots,C_n$ which share the unique state $q_m$. Moreover, without loss of generality, we assume that $O(q_m) = a_0 + a_1 x_1 + \dots + a_k x_k + b_1 y_1 + \dots + b_l y_l$, and $O(q)$ is undefined for all the other states $q$.

From Proposition~\ref{prop-sum-path}, we know that a function $\chi_H$ can be constructed to summarize the computation of $\Ss$ on the handle. Let $d^{(0)}_{1}, \dots, d^{(0)}_{r_H}$ denote the $r_H$ data values introduced in the handle. Because all the values of the control and data variables are $\bot$ (undefined) in the initial configuration,  we can concretize $\chi_H$ as follows. 
\begin{itemize}
\item There is an injective mapping $\pi_H: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi_H(j) \le k$, then $\pi_H(j)=j$ and $\chi_H(x_j)=\bot$, otherwise, $\chi_H(x_j)=d^{(0)}_{\pi_H(j)-k}$. Without loss of generality, we assume $\pi_H(j) > k$ for each $j: 1\le j \le k$. Intuitively, this means that after traversing the handle $H$, the values of all control variables are defined (i.e. not $\bot$).
% 
\item For each $y_j \in Y$, $\chi_H(y_j) = \alpha^{(H)}_{j,0} + \alpha^{(H)}_{j,1} o_j + \gamma^{(H)}_{j,1} d^{(0)}_1 +\dots + \gamma^{(H)}_{j,r_H} d^{(0)}_{r_H}$ such that $\alpha^{(H)}_{j,1} \in \{0,+1,-1\}$. Since the initial value of the control variable $y_j$ is $o_j=\bot$, we assume that $\alpha^{(H)}_{j,1}=0$, without loss of generality.
\end{itemize}

Moreover, from Proposition~\ref{prop-sum-cycle}, we know that for each cycle $C_i$ ($1 \le i \le n$), a function $\chi^{(C_i)}_{\ell}$ can be constructed to summarize the computation of $\Ss$ on $C^{\ell}_i$ (the iteration of $C_i$ for $\ell$ times).

A \emph{cycle scheme} $\schm$ is a path $H C_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that $i_1,\dots,i_t \in \{1,\dots,n\}$, $\ell_1,\dots, \ell_t \ge 1$, and for each $j: 1 \le j < t$, $i_j \neq i_{j+1}$. Intuitively, $\schm$ is a path obtained by traversing $H$ first, then iterating $C_{i_1}$ for $\ell_1$ times, $C_{i_2}$ for $\ell_2$ times, and so on. From Corollary~\ref{cor-comp-two-paths}, we know that a function $\chi_{\schm}$ can be constructed by composing $\chi_{H}, \chi^{(C_{i_1})}_{\ell_1},\dots,\chi^{(C_{i_t})}_{\ell_t}$, to summarize the computation of $\Ss$ on $\schm$.

\begin{proposition}\label{prop-cycle-schm}
Let $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ be a cycle scheme. Then for each $j'$ such that $j' \le k$ and $\pi_{C_{i_1}}(j')=j'$, the following expression occurs in $\chi_{\schm}(O(q_m))$,
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) d^{(0)}_{\pi_H(j')-k}. 
\]
\end{proposition}

\begin{proof}
At first,  let us check $\chi^{(C_{i_1})}_{\ell_1}(O(q_m))$.
\[
\begin{array}{l c l}
\chi^{(C_{i_1})}_{\ell_1}(O(q_m)) & = & a_0 + a_1 \chi^{(C_{i_1})}_{\ell_1}(x_1) + \dots a_k \chi^{(C_{i_1})}_{\ell_1}(x_k) + \\
& & b_1 \chi^{(C_{i_1})}_{\ell_1}(y_1) + \dots + b_l \chi^{(C_{i_1})}_{\ell_1}(y_l).
\end{array}
\] 

Then $\chi^{(C_{i_1})}_{\ell_1}(O(q_m))$ is a linear combination of the variables $d^{(0)}_1,\dots, d^{(0)}_{r_H}$ and $d^{(C_{i_1},1)}_1,\dots, d^{(C_{i_1},1)}_{r_{C_{i_1}}}, \dots, d^{(C_{i_1},\ell_1)}_1,\dots, d^{(C_{i_1},\ell_1)}_{r_{C_{i_1}}}$.

For each $j'$ such that $j' \le k$ and $\pi_{C_{i_1}}(j')=j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ in $\chi^{(C_{i_1})}_{\ell_1}(O(q_m))$ is 

\[a_{j'} + \sum \limits_{1 \le j \le l} b_j \left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}.\]
%
%
For each $j: 1 \le j \le l$, $\chi_{\schm}(y_j)$ contains the following expression 
\[\left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right)\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'} d^{(0)}_{\pi_H(j')-k}.\]

Since 
\[
\chi_{\schm}(O(q_m)) = a_0 + a_1 \chi_{\schm}(x_1) + \dots a_k \chi_{\schm}(x_k) + b_1 \chi_{\schm}(y_1) + \dots + b_l \chi_{\schm}(y_l),
\] 
it is not hard to see that $\chi_\schm(O(q_m))$ contains the expression,
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) d^{(0)}_{\pi_H(j')-k}. 
\]
\qed
\end{proof}

We are ready to present the decision procedure.

\smallskip

\noindent {\bf Step I}. Decide whether $\chi_H(O(q_m))$ is not identical to zero (it is easy to do so, just check the coefficients of $d^{(0)}_1, \dots, d^{(0)}_{r_H}$). If the answer is yes, then the decision procedure terminates and returns the answer $\ltrue$. Otherwise, go to Step II. \qed

\smallskip

\noindent {\bf Step II}. For each cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$, from Proposition~\ref{prop-cycle-schm}, we know that $\chi_{\schm}(O(q_m))$ contains the following expression,
\[
\left(\sum \limits_{1 \le j \le l} 
\begin{array}{l}
b_j \left((\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \dots (\alpha^{(C_{i_t})}_{j,1})^{\ell_t}\right) \\
\left(1+\alpha^{(C_{i_1})}_{j,1} + \dots + (\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'}
\end{array}
\right) d^{(0)}_{\pi_H(j')-k}. \ \ \  (\ast)
\]
Since $\alpha^{(C_{i_2})}_{j,1}, \dots, \alpha^{(C_{i_t})}_{j,1} \in \{0,+1\}$, the expression $(\ast)$ is of the form 
\[
a_{j'} + \sum \limits_{1 \le j \le l} b_j  s_{\schm,j} \left(1+\alpha^{(C_{i_1})}_{j,1} + \dots +(\alpha^{(C_{i_1})}_{j,1})^{\ell_1-1} \right) \beta^{(C_{i_1})}_{j,j'},
\]
where $s_{\schm,j} \in \{0,+1\}$. Then the expression $(\ast)$ can be rewritten as $\mu_{\schm, (i_1,j')} \ell_1 + \nu_{\schm, (i_1,j')}$ for some integer constant $\mu_{\schm, (i_1,j')},\nu_{\schm, (i_1,j')}$ (possibly $\mu_{\schm, (i_1,j')}=0$). 

For each $i_1: 1 \le i_1 \le n$, if there are a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$  and $j'$ such that 
\begin{itemize}
\item $i_2,\dots,i_t$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
\item $j' \le k$, $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$, 
\end{itemize}
then return $\ltrue$.

If the decision procedure has not return yet, then go to Step III. \qed

\smallskip

Note that for a cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$ such that $j' \le k$, $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$, we can let $d^{(0)}_{\pi_H(j')-k} \neq 0$, and let $\ell_1$ sufficiently large, so that $(\mu_{\schm,(i_1,j')} \ell_1 + \nu_{\schm,(i_1,j')})d^{(0)}_{\pi_H(j')-k}$ dominates $\chi_{\schm}(O(q_m))$, and  $\chi_{\schm}(O(q_m))$ becomes non-zero. 

We would like to remark that although in Step II, we do not consider all the cycle schemes, the set of cycle schemes chosen in Step II does exhaust all the possible values of $s_{\schm,j}$ when $\schm$ varies.


\medskip

\noindent {\bf Claim}. 
{\it 
Suppose the decision procedure has not returned yet after Step II. For each cycle scheme $\schm=HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}$, each $s: 1 \le s \le t$, and each $y_j \in Y$, let $(\chi^{(\Cc_{i_s})}_{\ell_s})'(y_j)$ denote the expression obtained by removing from $\chi^{(\Cc_{i_s})}_{\ell_s}(y_j)$  all the expressions of the form $c\ \ell_s$ (where $c$ is an integer constant).  Moreover, let $\chi'_\schm$ be the composition of $\chi_H$, $(\chi^{(\Cc_{i_1})}_{\ell_1})'$, $\dots$, and $\chi^{(\Cc_{i_t})}_{\ell_t})'$. Then the following two facts hold.
\begin{enumerate}
\item There is an assignment of values to the variables such that $\chi_\schm(O(q_m))$ becomes non-zero iff there is an assignment of values to the variables such that $\chi'_\schm(O(q_m))$ becomes non-zero.
%
\item All the coefficients in $\chi'_\schm(y_j)$ (where $y_j \in Y$) are from a bounded domain $D$, no matter whatever $\schm$ is. Moreover a finite state automaton $\Aa$ can be constructed from $\chi_H,\chi_{C_1},\dots,\chi_{C_n}$ to record the evolvement of these coefficients  in the cycle schemes.
\end{enumerate}
}

\begin{proof}
Because Step II has already considered the evolvement of the coefficients of $d^{(0)}_{\pi_H(j')-k}$ by varying the cycle scheme $\schm$, it is not hard to get the first fact.

We prove the second fact in the following. We exemplify the proof for $t=2$. 
For each $y_j \in Y$, we will illustrate the argument for the situation that $\alpha^{(C_{i_1})}_{j,1} = 1$ and $\alpha^{(C_{i_2})}_{j,1} = 1$.

Suppose $\alpha^{(C_{i_1})}_{j,1} = 1$ and $\alpha^{(C_{i_2})}_{j,1} = 1$. Then in $\chi'_\schm(y_j)$,
\begin{itemize}
\item the constant coefficient is $0 + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\  0 = 0$ (here $\alpha^{(C_{i_2})}_{j,0} \ell_2$ and $\alpha^{(C_{i_1})}_{j,0} \ell_1$ are removed),
%
%\item the coefficient of $o_j$ is $1$,
%
\item for each $j' \le r_{H}$ such that $j' \not \in \{\pi_H(j'')-k \mid 1 \le j'' \le k\}$, the coefficient of $d^{(0)}_{j'}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(H)}_{j'} = \gamma^{(H)}_{j'}$,
%
\item for each $j' \le k$ such that $\pi_{C_{i_1}}(j') = j'$ and $\pi_{C_{i_2}}(j') = j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ is $0 + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\ 0 = 0$ (here $\beta^{(C_{i_2})}_{j,j'} \ell_2$ and $\beta^{(C_{i_1})}_{j,j'} \ell_1$ are removed),
%
\item for each $j' \le k$ such that $\pi_{C_{i_1}}(j') = j'$ and $\pi_{C_{i_2}}(j') \neq j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ is $\beta^{(C_{i_2})}_{j,j'} + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\ 0 = \beta^{(C_{i_2})}_{j,j'}$ (here $\beta^{(C_{i_1})}_{j,j'} \ell_1$ is removed),
%
\item for each $j' \le k$ such that $\pi_{C_{i_1}}(j') \neq j'$, the coefficient of $d^{(0)}_{\pi_H(j')-k}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2}\ \beta^{(C_{i_1})}_{j,j'} = \beta^{(C_{i_1})}_{j,j'}$,
%
\item if $\ell_1>1$, then for each $j' \le r_{C_{i_1}}$ such that $j'+k \in \rng(\pi_{C_{i_1}})$ and each $i: 1 \le i < \ell_1$, the coefficient of $d^{(C_{i_1},i)}_{j'}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} (\beta^{(C_{i_1})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)}+\gamma^{(C_{i_1})}_{j,j'}) = \beta^{(C_{i_1})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)}+\gamma^{(C_{i_1})}_{j,j'}$,
%
\item if $\ell_1>1$, then for each $j' \le r_{C_{i_1}}$ such that $j'+k \not \in \rng(\pi_{C_{i_1}})$ and each $i: 1 \le i < \ell_1$, the coefficient of $d^{(C_{i_1},i)}_{j'}$ is the expression $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'} = \gamma^{(C_{i_1})}_{j,j'}$,
%
\item for each $ j' \le r_{C_{i_1}}$ such that $j'+k \in \rng(\pi_{C_{i_1}})$ and $\pi_{C_{i_2}}(\pi^{-1}_{C_{i_1}}(j'+k))=\pi^{-1}_{C_{i_1}}(j'+k)$, the coefficient of $d^{(C_{i_1},\ell_1)}_{j'}$ is $0 + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'} = \gamma^{(C_{i_1})}_{j,j'}$ (here $\beta^{(C_{i_2})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)} \ell_2$ is removed),
%
\item for each $ j' \le r_{C_{i_1}}$ such that $j'+k \in \rng(\pi_{C_{i_1}})$ and $\pi_{C_{i_2}}(\pi^{-1}_{C_{i_1}}(j'+k)) \neq \pi^{-1}_{C_{i_1}}(j'+k)$, the coefficient of $d^{(C_{i_1},\ell_1)}_{j'}$ is $\beta^{(C_{i_2})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)} + (\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'}$ $=$ $\beta^{(C_{i_2})}_{j, \pi^{-1}_{C_{i_1}}(j'+k)}$ $+$ $\gamma^{(C_{i_1})}_{j,j'}$,
%
\item for each $j' \le r_{C_{i_1}}$ such that $j'+k \not \in \rng(\pi_{C_{i_1}})$, the coefficient of $d^{(C_{i_1},\ell_1)}_{j'}$ is $(\alpha^{(C_{i_2})}_{j,1})^{\ell_2} \gamma^{(C_{i_1})}_{j,j'} = \gamma^{(C_{i_1})}_{j,j'}$,
%
\item all the other coefficients are those in $\chi^{(C_{i_2})}_{\ell_2}(y_j)$ for the data values introduced in $C^{\ell_2}_{i_2}$.
\end{itemize} 
From the analysis above, we know that when composing $(\chi^{C_{i_1}}_{\ell_1})'$ with $(\chi^{C_{i_2}}_{\ell_2})'$, given a $j': j' \le r_{C_{i_1}}$, the coefficients of all the data values $d^{(C_{i_1},i)}_{j'}$ for $i: 1 \le i < \ell_1$ are the same. Moreover, they will keep the same even we keep composing with $(\chi^{C_{i_3}}_{\ell_3})'$, $(\chi^{C_{i_4}}_{\ell_4})'$, and so on. Therefore, we only need record one copy of these coefficients and there are only a bounded number of coefficients to remember. Then we can construct a finite state automaton $\Aa$ from $\chi_H,\chi_{C_1},\dots,\chi_{C_n}$ to record these coefficients in the states and simulate the evolvement of these coefficients. The final states of $\Aa$ represent the coefficients obtained when reaching the state $q_m$ in $\Ss$. \qed
\end{proof}

\medskip 

\noindent {\bf Step III}. For each final state $\chi$ of $\Aa$ in the claim, check whether the constant coefficient or the coefficient of some data variable in $\chi(O(q_m))$ is nonzero. If the answer is yes, then return $\ltrue$, otherwise, return $\lfalse$.


%From the claim, it follows that the updates of the values of control and data variables along $\schm$, as well as the update of the value of the output expression $O(q_m)$, can be obtained by composing $\chi_H$, $(\chi^{(\Cc_{i_1})}_{\ell_1})'$, $\dots$, and $\chi^{(\Cc_{i_t})}_{\ell_t})'$, which can further be simulated by a $\intnum$-VASS $\Aa$, that is, an integer vector addition system with states (cf. \cite{HH14}). Then the non-zero output reachability of $\Ss$ is reduced to the non-zero reachability of $\Aa$, that is, given an index $i$, decide whether $\Aa$ can reach a vector $\vec{z}$ where $z_i \neq 0$. Finally, we decide the non-zero reachability of $\Aa$. If the answer is ``yes'', then return $\ltrue$, otherwise, return $\lfalse$.

%\begin{proposition}
%The non-zero reachability problem of $\intnum$-VASS is in NP.
%\end{proposition}
%
%\begin{proof}
%The non-zero reachability problem of $\intnum$-VASS can be reduced to the coverability problem of $\intnum$-VASS in polynomial time as follows: Given a $\intnum$-VASS $\Aa$ of dimension $m$ (that is, $m$ is the length of the integer vectors) and an index $i: 1 \le i \le m$, we construct a $\intnum$-VASS $\Bb$ as follows: From each final state of $\Aa$, nondeterministically we choose a subset $Idx \subseteq \{1,\dots,m\}$, and for each $i' \in Idx$, replace $z_{i'}$ by $-z_{i'}$. It is easy to see that $\Aa$ can reach a vector $\vec{z}$ where $z_i \neq 0$ iff $\Bb$ can reach a vector covering $(0,\dots,1,\dots,0)$, that is, the vector whose $i$-th component is $1$ and all the other components are zero.
%
% From the fact that the coverability of $\intnum$-VASS is NP-complete (\cite{HH14}), we know that the non-zero reachability problem of $\intnum$-VASS is in NP. \qed
%\end{proof}
%
%
%Therefore, in this case, the non-zero output reachability problem is reduced to the non-zero reachability problem of $\intnum$-VAS, 



\subsection{Decision procedure for SNTs}

We will illustrate the argument by the following situation, the transition graph comprises a handle $H=q_0\dots q_{m}$,  a collection of cycles $(C_1,\dots,C_n)$ such that $q_m$ is the unique state shared by each pair of them, another handle $H'=q'_0 \dots q'_{m'}$ such that $q'_0=q_m$, and another collection of cycles $(C'_1,\dots,C'_{n'})$ such that $q'_{m'}$ is the unique state shared by each pair of them. Moreover, $O(q'_{m'})$ is defined and $O(q)$ is undefined for all the other states $q$. Suppose $O(q'_{m'}) = a_0 + a_1 x_1 + \dots + a_k x_k + b_1 y_1 + \dots + b_l y_l$.

From Proposition~\ref{prop-sum-path}, we know that 
for the handle $H = q_0 \dots q_m$, a function $\chi_H$ can be constructed to summarize the computation on the handle. Suppose for each $j: 1 \le j \le l$,  $\chi_H(y_j) = \alpha^{(H)}_{j,0} + \gamma^{(H)}_{j,1} d^{(H,0)}_1 + \dots + \gamma^{(H)}_{j,r_H} d^{(H,0)}_{r_H}$, where $d^{(H,0)}_1,\dots, d^{(H,0)}_{r_H}$ represent the $r_H$ data values introduced in the handle. Moreover, there is an injective mapping $\pi_H$ from $\{1,\dots,k\}$ to $\{1,\dots,k+r_H\}$ such that for each $j: 1 \le j \le k$, $\chi_H(x_j) = d^{(H,0)}_{\pi_H(j)-k}$.

Similarly, for the handle $H' = q'_0 \dots q'_{m'}$, a function $\chi_{H'}$ can be constructed to summarize the computation on the handle. Let $d'_1,\dots,d'_k$ and $o'_1,\dots,o'_k$ denote the initial values of the control and data variables respectively. Then for each $j: 1 \le j \le l$,  $\chi_{H'}(y_j) = \alpha^{(H')}_{j,0} + \alpha^{(H')}_{j,1} o'_j + \beta^{(H')}_{j,1} d'_1 + \dots + \beta^{(H')}_{j,k} d'_{k}+ \gamma^{(H')}_{j,1} d^{(H',0)}_1 + \dots + \gamma^{(H')}_{j,r_{H'}} d^{(H',0)}_{r_{H'}}$, where $d^{(H',0)}_1,\dots, d^{(H',0)}_{r_{H'}}$ represent the $r_{H'}$ data values introduced in the handle. Moreover, there is an injective mapping $\pi_{H'}$ from $\{1,\dots,k\}$ to $\{1,\dots,k+r_{H'}\}$ such that for each $j: 1 \le j \le k$, if $\pi_{H'}(j)=j$, then $\chi_{H'}(x_j) = d'_j$, otherwise, $\chi_{H'}(x_j) = d^{(H',0)}_{\pi_{H'}(j)-k}$.

From Proposition~\ref{prop-sum-cycle}, we know that for $\ell \ge 1$, the functions $\chi^{(C_1)}_{\ell}$,$\dots$, $\chi^{(C_n)}_{\ell}$, $\chi^{(C'_1)}_{\ell}$, $\dots$, and $\chi^{(C'_{n'})}_{\ell}$ can be defined to summarize to computation on $C^{\ell}_1$, $\dots$, $C^{\ell}_n$, $(C'_1)^{\ell}$, $\dots$, and $(C'_n)^{\ell}$ respectively. 

Let us check the expression $\chi_{H'}(O(q'_{m'}))$ defined as follows,
\[
\begin{array}{l c l}
\smallskip
\chi_{H'}(O(q'_{m'})) & = & a_0 + a_1 \chi_{H'}(x_1) + \dots a_k \chi_{H'}(x_k) + \\
\smallskip
& & b_1 \chi_{H'}(y_1) + \dots + b_l \chi_{H'}(y_l) \\
\smallskip
&  = &  \left(a_0+\sum \limits_{1 \le j \le l} b_j \alpha^{(H')}_{j,0} \right) + \sum \limits_{j \le k, \pi_{H'}(j)=j} \left(a_j + \sum \limits_{1 \le j' \le l} b_{j'} \beta^{(H')}_{j,j'} \right) d'_j  + \\
%
& & \sum \limits_{j \le k, \pi_{H'}(j) \neq j} \left(\sum \limits_{1 \le j' \le l} (b_{j'} \beta^{(H')}_{j,j'})\right) d'_j + \sum \limits_{1\le j \le l} (b_{j} \alpha^{(H')}_{j,0}) o'_{j} + \\
\smallskip
%
& & \sum \limits_{1 \le j \le r_{H'}, j+k \in \rng(\pi_{H'})} \left(a_{(\pi_{H'})^{-1}(j+k)}+\sum \limits_{1 \le j' \le l} (b_{j'} \gamma^{(H')}_{j,j'})\right) d^{(H',0)}_j +\\ & & \dots  + \sum \limits_{1 \le j \le r_{H'}, j \not \in \rng(\pi_{H'})} \left(\sum \limits_{1 \le j' \le l} (b_{j'} \gamma^{(H')}_{j,j'})\right) d^{(H',0)}_j.
\end{array}
\] 
Let $a'_0,a'_1,\dots,a'_k,b'_1,\dots,b'_l$ denote the constant coefficient, the coefficients of $d'_1,\dots,d'_k$, and the coefficients of $o'_1,\dots,o'_l$ in $\chi_{H'}(O(q'_{m'}))$ respectively. 

Then we can adapt the output function $O$ and set $O(q_m) = a'_0 + a'_1 x_1 + \dots a'_k x_k + b'_1 y_1 + \dots b'_l y_l$.


\smallskip

\noindent {\bf Step I'}. By using the output expression $O(q_m)$, we can do the same analysis for the handle $H$ as for generalized lassos.

\smallskip 
\noindent {\bf Step II'}. At first, by using $O(q_m)$, we do the following computation, similarly to Step II: For each $i_1: 1 \le i_1 \le n$, if there are a cycle scheme $\schm$ of the form  
$HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t}
$
or 
$HC_{i_1}^{\ell_1} C_{i_2}^{\ell_2} \dots C_{i_t}^{\ell_t} (C'_{i'_1})^{\ell'_1} (C'_{i'_2})^{\ell'_2} \dots (C'_{i'_{t'}})^{\ell'_{t'}}$,
and $j' \le k$ such that 
\begin{itemize}
\item $i_2,\dots,i_t \le n$ are mutually distinct, $\ell_2 = \dots = \ell_t = 1$, 
%
\item $i'_1,\dots,i'_{t'} \le n'$ are mutually distinct, $\ell'_2 = \dots = \ell'_{t'} = 1$, 
%
\item $\pi_{C_{i_1}}(j')=j'$, and $\mu_{\schm,(i_1,j')} \neq 0$ (recall that $\mu_{\schm,(i_1,j')}$ is obtained from the coefficient of $d^{(0)}_{\pi_H(j')-k}$ in  $\chi_\schm(O(q_m))$), 
\end{itemize}
then return $\ltrue$. 

Then by using $O(q'_{m'})$, we do the following: For each $i'_1: 1 \le i'_1 \le n'$, if there are a cycle scheme $\schm' =(C'_{i'_1})^{\ell'_1} (C'_{i'_2})^{\ell'_2} \dots (C'_{i'_{t'}})^{\ell'_{t'}}$, and $j' \le k$ such that
\begin{itemize}
\item $i'_2,\dots,i'_t \le n'$ are mutually distinct, $\ell'_2 = \dots = \ell'_t = 1$, 
%
\item $\pi_{C'_{i_1}}(j')=j'$, and $\mu_{\schm',(i'_1,j')} \neq 0$ (here $\mu_{\schm',(i_1,j')}$ is obtained from the coefficient of $d''_{j'}$ in  $\chi_{\schm'}(O(q'_{m'}))$, where $d''_1,\dots,d''_k$ denote the initial data values of $x_1,\dots,x_k$ respectively),
\end{itemize}
then return $\ltrue$. 

If the decision procedure has not return yet, then go to Step III'. \qed

\smallskip

Similarly to the generalized lassos, we can construct a finite state automaton $\Aa'$ from $\chi_H,\chi_{C_1},\dots,\chi_{C_n},\chi_{H'}, \chi_{C'_1},\dots,\chi_{C'_{n'}}$ to record the coefficients in the states and simulate the evolvement of these coefficients. The final states of $\Aa$ represent the coefficients obtained when reaching the state $q'_{m'}$ in $\Ss$. 

\smallskip 

\noindent {\bf Step III'}. For each final state $\chi'$ of $\Aa'$ in the claim, check whether the constant coefficient or the coefficient of some data variable in $\chi'(O(q'_{m'}))$ is nonzero. If the answer is yes, then return $\ltrue$, otherwise, return $\lfalse$.

\zhilin{I stopped here}

\subsection{Comparisons with constants in guards}

We now consider the situation that the guards include the comparisons with constants, that is, the atomic formulae of the form $cur\ o\ c$, where $c$ is an integer constant. 

For this situation, we adapt the algorithm for a generalized lasso into Step I', II' and III' below.

\smallskip

\noindent {\bf Step I'}. Decide whether $\chi_0(O(q_m))$ is not identical to zero. If the answer is yes, then the decision procedure terminates and returns the answer $true$. Otherwise, the decision procedure continues.

When decide whether $\chi_0(O(q_m))$ is not identical to zero, it is unsound to just consider the coefficients of $d^0_1,\dots,d^0_s$, since some of the data values may be integer constants as well. 

From the analysis, we know that 
\[
\begin{array}{l c l }
\chi_0(O(q_m)) & = & a_0 + a_1 \chi_0(x_1) + \dots + a_k \chi_0(x_k) + a'_1 \chi_0(y_1) + \dots a'_l \chi_0(y_l).\\
& = & (a_0+a'_1 c_{0,1} + \dots + a'_l c_{0,l}) + \sum \limits_{j \not \in rng(\pi_0)}  (a'_1 c_{j,1}+\dots + a'_l c_{j,l}) d^0_j+\\
& & \sum \limits_{j \in rng(\pi_0)} (a_{\pi_0^{-1}(j)}+ a'_1 c_{j,1}+\dots + a'_l c_{j,l}) d^0_j.
\end{array}
\]

From the guards and assignments of the transitions in the handle, we know that some of $d^0_1,\dots,d^0_s$ are just integer constants. Let $J_0 \subseteq \{1,\dots,s\}$ denote the subset of indices for these data values. For $d^0_j$ such that $j \not \in J_0$, we know that either $d^0_j < c_{\min}$ or $d^0_j > c_{\max}$, since the SNT is assumed to be normalized.

Then to decide whether $\chi_0(O(q_m))$ is identical to zero, we will first check whether the coefficient of $d^0_j$ in $\chi_0(O(q_m))$ for some $j \not \in J_0$ is non-zero. If this is the case, the return ``$true$''. Otherwise, $\chi_0(O(q_m))$ is in fact an integer constant, and we just check whether it is equal to zero. If it is not equal to zero, then return ``true''. Otherwise, we continue the procedure.

For $b=1,2$, we know that $\chi_{b,1}(y_j) = \alpha_{b,(j,0)} + \alpha_{b,(j,1)} o_j + \beta_{b,(j,1)} d^0_{\pi_0(1)} + \dots + \beta_{b,(j,k)} d^0_{\pi_0(k)} + \gamma_{b,(j,1)} d^1_1 +\dots + \gamma_{b,(j,r_b)} d^1_{r_b}$.

Moreover, from the guards and assignments in the transitions of the handle and $C_b$, we know that some of $d^0_{\pi_0(1)}, d^0_{\pi_0(k)}, d^1_1,\dots, d^1_{r_b}$ are integer constants. From this, we know that for the data values $d^0_1,\dots, d^0_s, d^1_1,\dots, d^1_{r_b}, \dots, d^{\ell_b}_1,\dots, d^{\ell_b}_{r_b}$ introduced when traversing $C_b$ for $\ell_b$ times, which ones are integer constants.

\smallskip

\noindent {\bf Step II'}. For $\chi_{(b,\ell_b)}(O(q_m))$, we then do the analysis for the coefficient of $d^0_{\pi_0(j')}$ that is not a constant, similar to that in Step II.  Moreover, we consider the sum of the constant coefficient and all the components $c\ d^{i}_{j'}$ in  $\chi_{(b,\ell_b)}(O(q_m))$ such that $d^i_{j'}$ is a constant, and do the analysis for it, similar to that for the constant coefficient in Step II.

\smallskip

\noindent {\bf Step III'}. We will do the same analysis as in Step III.




\section{Case Studies}

	\begin{lstlisting}[mathescape=true]
	int MAD() {
	...
	// repeat the body  
	// of (b) to compute
	// sum and cnt
	
	init();
	avg:= sum/cnt;
	mad:=0;
	while(cur()$\neq$end()){
	if(cur()<avg){
	mad=mad+(avg-cur());
	}else{
	mad=mad+(cur()-avg);
	}
	next();
	}
	return mad/cnt;
	}
	\end{lstlisting}
	
\section{Discussions}

From the analysis of the commutativity of reducers in \cite{XZZ+14}, the commutativity of a reducer in a sequential composition oa map-reduce jobs may depend on some implicit data properties guaranteed by the preceding map-reduce jobs. Therefore, to analyze the commutativity of a reducer in a sequential composition of map-reduce jobs, we may need model both mappers and reducers and do a backward analysis.

\bibliographystyle{abbrv}
\bibliography{data}


\newpage

\begin{appendix}

\section{Proofs in Section~\ref{sec-def-snt}}

\noindent {\bf Proposition~\ref{prop-snt-cmm-to-eqv}}. 
\emph{The commutativity problem of SNTs is reduced to the equivalence problem of SNTs in exponential time}.

\begin{proof}
Suppose that $\Ss=(Q, X, Y, \delta, q_0, O)$ is a SNT. Without loss of generality, we assume that the output of $\Ss$ is defined only for data words of length at least two. We will construct two SNTs $\Ss_1$ and $\Ss_2$ so that $\Ss$ is commutative iff $\Ss$ is equivalent to both $\Ss_1$ and $\Ss_2$.
\begin{itemize}
\item The intuition of $\Ss_1$ is that over a data word $w=d_1 d_2 d_3 \dots d_n$ with $n\ge 2$, $\Ss_1$ simulates the run of $\Ss$ over $d_2 d_1 d_3 \dots d_n$, that is, the data word obtained from $w$ by swapping the first two data values.
%
\item The intuition of $\Ss_2$ is that over a data word $w=d_1 d_2 d_3 \dots d_n$ with $n\ge 2$, $\Ss_1$ simulates the run of $\Ss$ over $d_2 d_3 \dots d_n d_1$, that is, the data word obtained from $w$ by moving first data value to the end. 
\end{itemize}
The correctness of this reduction follows from Proposition 1 in \cite{CHSW15}.

\smallskip

\noindent {\it The construction of $\Ss_1$}.

Intuitively, over a data word $w=d_1d_2 d_3 \dots d_n$, we introduce an additional control variable $x'$ to store $d_1$, then simulates the run of $\Ss$ over $d_2 d_1 d_3 \dots d_n$ as follows: When reading $d_2$ in $w$, the data variables are updated properly by letting $x'$ to represent $d_1$ and $\cur$ to represent $d_2$.

Without loss of generality, we assume that for each pair of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2$ in $\Ss$, the following constraints are satisfied,
\begin{itemize}
\item $g_1$ does not contain any variable from $X$,
%
\item for each variable $x \in X$ such that $x$ occurs in $g_2$, it holds that $x \in \dom(\eta_1)$,
%
\item after these two transitions, the values of all the variables from $\dom(\eta_1) \cup \dom(\eta_2)$ are defined, more specifically, for each $y \in Y \cap \dom(\eta_2)$ and each $z \in \vars(\eta_2(y))$, it holds that $z \in \dom(\eta_1)$.
\end{itemize}

Let $q'_{0},q'_{1} \not \in Q$ and $x' \not \in X$. Then $\Ss_1 = (Q \cup \{q'_{0},q'_1\}, X \cup \{x'\}, Y, \delta_1, q'_{0}, O_1)$ such that 
\begin{itemize}
\item $O_1(q'_0)$ and $O_1(q'_1)$ are undefined, and for each $q \in Q$, $O_1(q)=O(q)$,
%
\item $\delta_1$ is constructed from $\delta$ as follows,
\begin{itemize}
\item each element of $\delta$ is an element of $\delta_1$,
%
\item for each pair of transitions $q_0 \xrightarrow{(g_1,\eta_1)} q_1 \xrightarrow{(g_2,\eta_2)} q_2$ in $\Ss$, we add the transitions $(q_0, \ltrue, \eta'_1, q'_1)$ and $(q'_1, g', \eta'_2, q_2)$ into $\delta_1$, where $\eta'_1,g',\eta'_2$ are defined in the following. Suppose $X \cap \dom(\eta_1)=\{x_1,\dots,x_k\}$, for each $y \in Y \cap \dom(\eta_1)$, $\eta_1(y)=a_{1,y} + b_{1,y}\cur$, and for each $y \in Y \cap \dom(\eta_2)$, 
\[\eta_2(y)=a_{2,y} + b_{2,y} \cur + c_{y,0} y + c_{y,1} x_1 + \dots + c_{y,k} x_k,\] 
or 
\[
\eta_2(y)=a_{2,y} + b_{2,y} \cur + c_{y,1} x_1 + \dots + c_{y,k} x_k.
\]
Then $\eta'_1, g', \eta'_2$ are defined as follows.
\begin{itemize}
\item $\eta'_1(x')=\cur$, for each $x \in X \cap \dom(\eta_2)$, $\eta'_1(x)=\cur$, and for all the other variables $z$ from $X \cup Y$, $\eta'_1(z)$ is undefined.
%
\item $g' = g_1 \wedge g'_2$, where $g'_2$ is obtained from $g_2$ by replacing $\cur$ with $x'$, and each $x \in X$ with $\cur$.
%
\item For each $x \in X$, if $x \in \dom(\eta_2)$, then $\eta'_2(x)$ is undefined, otherwise, if $x \in \dom(\eta_1)$, then $\eta'_2(x)=\cur$, otherwise, $\eta'_2(x)$ is undefined.
%
\item For each $y \in Y$, if $y \in \dom(\eta_2)$, then 
\[
\begin{array}{l c l}
\eta'_2(y) & = & a_{2,y} + b_{2,y} x' + c_{y,0} (a_{1,y} + b_{1,y}\cur) + c_{y,1} \cur + \dots + c_{y,k} \cur \\
& = & (a_{2,y} + c_{y,0} a_{1,y}) + b_{2,y} x' + (c_{y,0} b_{1,y}  + c_{y,1} + \dots + c_{y,k} )\cur,
\end{array}
\]
or 
\[
\begin{array}{l c l}
\eta'_2(y) & = & a_{2,y} + b_{2,y} x' + c_{y,1} \cur + \dots + c_{y,k} \cur \\
& = & a_{2,y} + b_{2,y} x' + (c_{y,1} + \dots + c_{y,k} )\cur.
\end{array}
\]
%
Otherwise, if $y \in \dom(\eta_1)$, then $\eta'_2(y)= a_{1,y} + b_{1,y} \cur$. Otherwise, $\eta'_2(y)$ is undefined.
\end{itemize}
\end{itemize}
\end{itemize}
It is easy to see that the size of $\Ss_1$ is polynomial with respect to the size of $\Ss$.

\smallskip

\noindent {\it The construction of $\Ss_2$}.

Intuitively, over a data word $w=d_1\dots d_n$, we introduce an additional control variable $x'$ to store $d_1$, then simulates the run of $\Ss$ over $d_2\dots d_n d_1$: When reaching the end of $w$, $\Ss_2$ outputs immediately by using $x'$ to represent $d_1$ and simulating the last transition of $\Ss$ over $d_2 \dots d_n d_1$. In order to simulate \emph{deterministically} the last transition of $\Ss$ over $d_2 \dots d_n d_1$ when reading the end of $w$ (since SNTs are required to be deterministic), we need record in the states of $\Ss_2$ the relationship between $d_1$ and all the values stored in the control variables. This implies an exponential blow-up of the size of $\Ss_2$ with respect to $\Ss$.

Let $c_{\max}$ and $c_{\min}$ denote the maximum resp. minimum constant occurring the guards of the transitions of $\Ss$.

Suppose $q'_{0} \not \in Q$ and $x' \not \in X$. Then $\Ss_2 = (Q', Y, \delta_2, q'_{0}, O_2)$, where $O',\delta_2,O_2$ are defined as follows. 
\begin{itemize}
\item $Q' = \{q_0\} \cup \left(\left([c_{\min}, c_{\max}] \cup \{-\infty,+\infty\}\right) \times X^{\{=, <, >,\bot\}} \right)$, where $[c_{\min},c_{\max}]= \{c \in \intnum \mid c_{\min} \le c \le c_{\max} \}$.
%
\item $\delta_2$ is defined as follows, 
\begin{itemize}
\item for each $c \in [c_{\min}, c_{\max}] \cup \{-\infty,+\infty\}$, $\delta_2$ contains $(q'_0,\ltrue,\eta, (q_0,(c, o_0)))$, where $\dom(\eta)=\{x'\}$, $\eta(x')=\cur$, and $o_0(x) = \bot$ for each $x \in X$,
%
\item for each $(q,g,\eta,q') \in \delta$ and $(q,(c,o)) \in Q'$ such that the guard $g \wedge \bigwedge \limits_{x \in X, o(x) \neq \bot} x'\ o(x)\ x$ is satisfiable, then $\delta_2$ contains the following three transitions, 
$((q,(c,o)), g \wedge \cur = x', \eta, (q',(c,o'_1)))$, $((q,(c,o)), g \wedge \cur< x', \eta, (q',(c,o'_2)))$, and $((q,(c,o)), g \wedge \cur > x', \eta, (q',(c,o'_3)))$, 
where 
for each $x \in X$, if $x \in \dom(\eta)$, then $o'_1(x) = \ =$, $o'_2(x)=\ >$, and $o'_3(x) =\ <$, otherwise, $o'_1(x) = o'_2(x) = o'_3(x) = o(x)$.
\end{itemize}
%
\item $O_2$ is defined as follows: For each $(q,(c,o)) \in Q'$  such that there is $(q,g,\eta,q') \in \delta$ satisfying that $\left(\bigwedge \limits_{x \in X, o(x) \neq \bot} \cur\ o(x)\ x \right) \models g$, and $O(q')$ is defined, suppose 
\[O(q')=a+b_1 x_1 + \dots + b_k x_k + c_1 y_1 + \dots + c_l y_l,\]
where $x_1,\dots,x_k$ (resp. $y_1,\dots,y_l$) are pairwise distinct variables from $X$ (resp. $Y$),
then let
\[O_2((q,(c,o)))=a+b_1 \eta'(x_1) + \dots + b_k \eta'(x_k) + c_1 \eta'(y_1) + \dots + c_l \eta'(y_l),\]
where for each $z \in \dom(\eta)$, $\eta'(z)=\eta(z)$, and for all the other variables $z' \in X \cup Y$, $\eta'(z')=z'$.  \\
Note that $O_2$ is well-defined since for each $(q,(c,o)) \in Q'$, there is a unique $(q,g,\eta,q') \in \delta$ satisfying the aforementioned constraint.
\end{itemize}
%
Note that $\Ss_1$ and $\Ss_2$ constructed above preserve the generalized flatness of $\Ss$.
\qed
\end{proof}


\noindent {\bf Proposition \ref{prop-snt-eqv-to-nzero}}.
\emph{From SNT $\Ss_1$ and $\Ss_2$, a SNT $\Ss_3$ can be constructed in polynomial time such that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss_3$ over $w$ is nonzero.}

\begin{proof}
Let $\Ss_1 = (Q_1,X_1,Y_1,\delta_1,q_{1,0}, O_1)$ and  $\Ss_2 = (Q_2,X_2,Y_2,\delta_2,q_{2,0}, O_2)$ be two SNTs. Without loss of generality, we assume that $Q_1 \cap Q_2 = \emptyset$, $X_1 \cap X_2 = \emptyset$, and $Y_1 \cap Y_2 = \emptyset$. 

Intuitively, we construct $\Ss$ as the product of $\Ss_1$ and $\Ss_2$. Specifically, $\Ss=(Q_1 \times Q_2, X_1 \cup X_2, Y_1 \cup Y_2, \delta, (q_{1,0},q_{2,0}), O)$, where
\begin{itemize}
\item $\delta$ comprises $((q_1,q_2), g_1 \wedge g_2, \eta_1 \cup \eta_2, (q'_1,q'_2))$ such that $(q_1,g_1,\eta_1,q'_1) \in \delta_1$ and $(q_2,g_2,\eta_2,q'_2) \in \delta_2$,
%
\item for each $(q_1,q_2) \in Q_1 \times Q_2$, 
\begin{itemize}
\item if $O_1(q_1)$ is defined and $O_2(q_2)$ is undefined or vice versa, then $O((q_1,q_2))=1$, 
%
\item otherwise, if both $O_1(q_1)$ and $O_2(q_2)$ are defined, then $O((q_1,q_2))=O_1(q_1) - O_2(q_2)$, 
%
\item otherwise (both $O_1(q_1)$ and $O_2(q_2)$ are undefined), $O((q_1,q_2))$ is undefined. 
\end{itemize}
\end{itemize}
From the aforementioned construction and the assumption that $\Ss$ is well-defined, it is easy to see that $\Ss_1$ and $\Ss_2$ are  inequivalent iff there is a data word $w$ such that the output of $\Ss$ over $w$ is non-zero.\qed
\end{proof}


\section{Proofs in Section~\ref{sec-dec-snt}}


\noindent {\bf Proposition~\ref{prop-snt-norm}}.
{\it From each SNT, an equivalent normalized SNT can be constructed in exponential time.} 

\smallskip

\begin{proof}
To be done.
\qed
\end{proof}


\noindent {\bf Proposition~\ref{prop-sum-path}}.
{\it The values of the control and data variables after traversing the path $P$ are specified by a function $\chi$ satisfying the following conditions.
\begin{itemize}
\item There is an injective mapping $\pi: \{1,\dots,k\} \rightarrow \{1,\dots, k+r\}$ such that for each $x_j \in X$, if $\pi(j) \le k$, then $\pi(j)=j$ and $\chi(x_j)=d^{(0)}_{j}$, otherwise, $\chi(x_j)=d^{(1)}_{\pi(j)-k}$.
% 
\item For each $y_j \in Y$, $\chi(y_j) = \alpha_{j,0} + \alpha_{j,1} o_j + \beta_{j,1} d^{(0)}_1 + \dots + \beta_{j,k} d^{(0)}_k + \gamma_{j,1} d^{(1)}_1 +\dots + \gamma_{j,r} d^{(1)}_{r}$ for some constants $\alpha_{j,0},\alpha_{j,1}, \beta_{j,1},\dots,\beta_{j,k}, \gamma_{j,1},\dots,\gamma_{j,r}$ such that $\alpha_{j,1} \in \{0,+1,-1\}$ (as a result of the ``independently evolving and copyless'' constraint).
\end{itemize}
}

\begin{proof}
We show by an induction that for each $i: 1 \le i \le n$ and each variable $x_j \in X$ (resp. $y_j \in Y$), an expression $e_{i,x_j}$ (resp. $e_{i,y_j}$) can be constructed to describe the value of $x_j$(resp. $y_j$) after going through the first $i$ transitions of the path. 
%
\begin{itemize}
\item Let $\theta_0$ be an assignment such that for each $x_j \in X$ (resp. $y_j \in Y$), $\theta_0(x_j)=d^{(0)}_j$ (resp. $\theta_0(y_j)=o_j$), moreover, $\theta_0(\cur)=d^{(1)}_1$.
%
%\item For each $x_j \in X$, if $x_j \in \dom(\eta_1)$, then $e_{1,x_j}=d^{(1)}_1$, otherwise, $e_{1,x_j}=d^{(0)}_j$. For each $y_j \in Y$, if $y_j \in \dom(\eta_1)$, then $e_{1,y_j} = \theta_0(\eta_{1}(y_j))$,
%otherwise, $e_{1,y_j}=o_j$. 
%
\item Let $i: 1 \le i \le n$. 
\begin{itemize}
\item For each $x_j \in X$, if $x_j \in \dom(\eta_i)$, then $e_{i,x_j}=\theta_{i-1}(\cur)$, otherwise, $e_{i,x_j}=\theta_{i-1}(x_j)$.
%
\item For each $y_j \in Y$, if $y_j \in \dom(\eta_i)$, then $e_{i,y_j} = \theta_{i-1}(\eta_i(y_j))$, otherwise, $e_{i,y_j}=\theta_{i-1}(y_j)$.
%
\item For each $x_{j} \in X$ (resp. $y_j \in Y$), $\theta_i(x_{j})=e_{i,x_{j}}$ (resp. $\theta_i(y_{j})=e_{i, y_{j}}$). If $i < n$, then $\theta_i(\cur)=d^{(1)}_{s}$, where $1\le s \le r$ and $k+i + 1 \in I_s$, otherwise, $\theta_i(\cur)=\bot$.
\end{itemize}
\end{itemize}
Then the function $\chi$ can be defined as the restriction of $\theta_n$ to $X \cup Y$.
\qed
\end{proof}


\noindent {\bf Proposition~\ref{prop-sum-cycle}}.
{\it Suppose $P=C^{\ell}$ such that $\ell \ge 2$. Then the function $\chi^{(C)}_{\ell}$ to summarize the computation of $\Ss$ on $P$ is defined as follows,
\[
\begin{array}{l c l}
\chi^{(C)}_{\ell}(y_j)  & = & (\alpha^{(C)}_{j,0} + \alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0}+ \dots +(\alpha^{(C)}_{j,1})^{\ell-1} \alpha^{(C)}_{j,0}) + (\alpha^{(C)}_{j,1})^\ell o_j + \\
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1}\beta^{(C)}_{j,j'} + \dots +(\alpha^{(C)}_{j,1})^{\ell-1}  \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \\
%
& & \sum \limits_{j'\le k, \pi_C(j') \neq j'} ((\alpha^{(C)}_{j,1})^{\ell-1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} +  \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} ( (\alpha^{(C)}_{j,1})^{\ell-2} \beta^{(C)}_{j, \pi_C^{-1}(j'+k)} +(\alpha^{(C)}_{j,1})^{\ell-1}\gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} ((\alpha^{(C)}_{j,1})^{\ell-1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + \dots + \\
%
& & \sum \limits_{j' \le r_C, j'+k \in \rng(\pi_C)} (\beta^{(C)}_{j, \pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1}\gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \\
%
& & \sum \limits_{j' \le r_C,  j'+k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,\ell-1)}_{j'} + \gamma^{(C)}_{j, 1} d^{(C,\ell)}_{1} + \dots + \gamma^{(C)}_{j,r_C} d^{(C,\ell)}_{r_C},
\end{array} 
\]
where $d^{(C,2)}_{1},\dots, d^{(C,2)}_{r_C},\dots, d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$
 are the data values introduced when traversing $C$ for the second time, $\dots$, and for $\ell$ times.
}
%
\begin{proof}
Let $d^{(C,2)}_{1},\dots,d^{(C,2)}_{r_C}$ be the data values introduced when traversing the cycle for the second time. Then from Corollary~\ref{cor-comp-two-paths}, we know that $\chi^{(C)}_2 = \chi_{C} \circ \chi_C$ is defined as follows: For each $y_j \in Y$,
\[
\begin{array}{l c l}
\smallskip
\chi^{(C)}_2(y_j) & =  & (\alpha^{(C)}_{j,0}+\alpha^{(C)}_{j,1} \alpha^{(C)}_{j,0})+ (\alpha^{(C)}_{j,1})^2 o_j + \\
%
\smallskip
& & \sum \limits_{j' \le k, \pi_C(j')=j'} (\beta^{(C)}_{j,j'}+\alpha^{(C)}_{j,1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'} + \sum \limits_{j' \le k, \pi_C(j') \neq j'} (\alpha^{(C)}_{j,1} \beta^{(C)}_{j,j'}) d^{(0)}_{j'}  \\
%
& & + \sum \limits_{j' \le r_C, j' + k \in \rng(\pi_C)} (\beta^{(C)}_{j,\pi_C^{-1}(j'+k)}+\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} +\\
%
& & \sum \limits_{j' \le r_C, j' + k \not \in \rng(\pi_C)} (\alpha^{(C)}_{j,1} \gamma^{(C)}_{j,j'}) d^{(C,1)}_{j'} + 
 \gamma^{(C)}_{j,1} d^{(C,2)}_1 +\dots + \gamma^{(C)}_{j,r_C} d^{(C,2)}_{r_C}.
\end{array}
\] 
For $\ell > 3$, let $d^{(C,\ell)}_{1},\dots,d^{(C,\ell)}_{r_C}$ be the data values introduced when traversing the cycle for the $\ell$-th time. Then from Corollary~\ref{cor-comp-two-paths}, the fact $\chi^{(C)}_\ell = \chi_C \circ \chi^{(C)}_{\ell-1}$, and the induction hypothesis, we can show that $\chi^{(C)}_\ell$ is of the desired form.
\qed
\end{proof}


\end{appendix}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



