%!TEX root = main-cav.tex
 
\section{Language For Integer Reducers}\label{sec-mr-prog}
\label{sec:language}
We discuss the rationale behind the design of the programming language for reducers such that the commutativity problem is decidable.
We focus on a language that only allow to iterate though the input list once. Later in Section~\ref{sec:cases} we will show an extension that allows the reset of list iterators.

\begin{figure}
	\vspace{-0.5cm}
	\centering
	\begin{tabular}{rcl}
        $ s \in Statements$&$\equiv$&$y := e\mid y \addeq e \mid x:=x'\mid s;s\mid \nnext \mid \ite{g}{s}{s}$\\
		$ p\in Programs$&$\equiv$&$\loopL{s};\mbox{ret }r \mid s;p$		
	\end{tabular}
	\label{fig:language}
	\caption{A Simple Programming Language for Reducers. Here $x\in X$ are control variables, $y\in Y$ are data variables, $x' \in X^+$, $e\in \Ee_{X^+}$ are expressions, $r$ is an expression in $\Ee_{X \cup Y}$, and $c\in \mathbb{Z}$.}
	\vspace{-0.5cm}
\end{figure}

To be more concrete, we focus on the programming language in Figure~\ref{fig:language} (formal semantics is given in the appendix).
The main feature of the language is that we partition the variables into two sets: \emph{control variables} and \emph{data variables}.
The former are used for guiding the program flow and the latter used for storing aggregated results.
To be more specific, the control variables can store only values occurred in the input and can be used either in guard or arithmetic expressions.
The data variables can store the results obtained from an arithmetic expression, but cannot be used either in guards or arithmetic expressions.

Note that we do not allow multiplication in the language, so the reduction from the satisfiability of Diophantine equations no longer works. Even though, if we do not distinguish the control and data variables, we can show easily that basic decision problems for this language are still undecidable, by a reduction from the reachability problem of Perti-net with zero test~\cite{petri}.
Intuitively, variables are used for remembering the number of tokens in each place. Transitions between places can be described as assignments to variables in the loop body: each loop iteration makes a Petri-net transition. 
The non-determinism in transitions is expressed by branching over the input. 
The guards in transitions are expressed by branching over the variables (recall that we are discussing the version that we do not distinguishing data and control variables). Then the reachability problem of Perti-net with zero test can be reduced to reachability problem in the programming language.

Notice that in the programming language, we only allow additions ($\addeq$) or assignments ($:=$) of a new value computed from an expression over $X^+$ to data variables. 
We argue that this is sufficient for reducers performing data analytics operations.
In Figure~\ref{fig:examples} we demonstrate a few simple examples of reducers performing data analytics operations. Observe that all of them follow the same behavioral pattern; the program iterates through the input list and aggregates the processed result in some variables. The operation used for the aggregation is usually ratter simple; it either adds a new value (like the cases \texttt{sum} and \texttt{cnt} in Figure~\ref{fig:examples}) or assigns a new value (like the cases {\texttt max\_abs} and {\texttt 2nd\_largest} in Figure~\ref{fig:examples}) to the variable storing the aggregated result. Actually, the same behavioral pattern occurs in all programs we have investigated.

\input{example1}


The observation is actually not a big surprise. The \emph{reduce} operation in MapReduce has a tight relation with the \emph{fold} operation in functional languages, which aggregates the values in a list using a \emph{binary function} and returns one value. Here the data variables are used for storing the aggregated results. Since we allows only add and subtract operations in the programming language, we do not need more than ``adds/assigns a value to data variables'' to describe the binary function of fold operations. Hence we argue that our language is sufficient to describe programs that can be described by the \emph{fold} operation in functional languages (with only additions and subtractions). On the other hand, our language is more flexible than a fold operation in the sense that we have full control of what to do while iterating through the list (similar to Hadoop~\cite{Hadoop}).
 
We are interested in two decision problems: (1) \emph{Commutativity}: given a program $p$, decide whether for each list $l$ and its permutation $l'$, $p(l) = p(l')$. (2) \emph{Equivalence:} given programs $p,p'$, decide whether for each list $l$, $p(l)=p(l')$.

One may argue that allowing only addition and subtraction is too restrictive for data analytics. 
In Section~\ref{sec:cases}, we will discuss possible extensions of the framework to support more challenging examples, such as computing \emph{Mean Absolute Deviation} and \emph{Standard Deviation}.



